<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何在Linux上使用xargs命令</title><link rel="stylesheet" href="/css.css"><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?f75329719d379998b2421a4cc2396366";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="header"><a class="site_title" href="http://www.fuzadu.com">复杂度</a></div><div><div><h2>如何在Linux上使用xargs命令</h2></div><div class="content"><p>需要将一些Linux命令串在一起，但其中一个命令不接受管道输入？xargs可以从一个命令获取输出并将其作为参数发送到另一个命令。</p><p>所有标准的Linux实用程序都有三个与之相关联的数据流。它们是标准输入流(Stdin)、标准输出流(Stdout)和标准错误流(Stderr)。</p><p>这些流与文本一起工作。我们使用文本向命令发送输入(Stdin)，响应(Stdout)以文本形式写入终端窗口。错误消息也会以文本(Stderr)的形式写入终端窗口。</p><p>Linux和类Unix操作系统的一大特性是能够将一个命令的stdout输出通过管道传输到第二个命令的stdin输入。第一个命令并不关心它的输出是否不会进入终端窗口，第二个命令也不关心它的输入是否不是来自键盘。</p><p>尽管所有Linux命令都有三个标准流，但并非所有命令都接受另一个命令的stdout作为其stdin的输入。这意味着您不能通过管道输入到它们。</p><p>xargs是使用标准数据流构建执行管道的命令。通过使用xargs，我们可以使诸如echo、rm和mkdir之类的命令接受标准输入作为参数。</p><p>xargs命令</p><p>xargs将接受管道输入。它还可以接受来自文件的输入。xargs使用该输入作为我们告诉它使用的命令的参数。如果我们不告诉xargs使用特定命令，它将默认使用echo。</p><p>我们可以使用它来演示xargs如何始终生成单行输出，即使是从多行输入。</p><p>如果我们将-1(每行列出一个文件)选项与ls一起使用，我们将获得单列文件名。</p><code>ls -1 ./*.sh</code><img class="content_img" src="/image/c7/c734350810f58bea1ad48ec8347f90fe.png" /><p>这将列出当前目录中的shell脚本文件。</p><img class="content_img" src="/image/48/48188ba400f05497ca80e79f741baa88.png" /><p>不出所料，我们得到了一个单独的专栏。如果我们用管道通过xargs，我们会得到什么？</p><code>ls -1 ./*.sh | xargs</code><img class="content_img" src="/image/75/7561207d3634c17d0d2421622adc21f9.png" /><p>输出以一个长文本流的形式写入终端窗口。</p><img class="content_img" src="/image/39/39a6da7980cc8d1d48dda335bc202c7e.png" /><p>正是这种功能让我们将参数xargs馈送到其他命令中。</p><p>将xargs与wc一起使用</p><p>我们可以使用xargs轻松地让WC计算多个文件中的单词、字符和行。</p><code>ls *.page | xargs wc</code><img class="content_img" src="/image/1b/1bfd202b84460cdde829539f87985372.png" /><p>事情是这样的：</p><p>
ls列出*.page文件并将该列表传递给xargs。
xargs将文件名传递给wc。
WC会将文件名视为已收到的命令行参数。</p><img class="content_img" src="/image/76/76934fc87df66051205bbbd82dd5f3da.png" /><p>每个文件的统计数据与总体合计一起显示。</p><p>使用带有确认的xargs</p><p>我们可以使用-p(交互式)选项让xargs提示我们确认我们是否乐于继续。</p><p>如果我们通过xargs传递一个文件名字符串给Touch，那么Touch将为我们创建文件。</p><code>echo 'one two three' | xargs -p touch</code><img class="content_img" src="/image/ed/ed4d6ad0898a34b3eec04f6d94c8bd81.png" /><p>将显示要执行的命令，xargs等待我们通过键入“y”或“Y”、或“n”或“N”进行响应，然后按Enter键。</p><p>如果您只按Enter键，它将被视为“n”。只有当您键入“y”或“Y”时，才会执行该命令。</p><img class="content_img" src="/image/aa/aaef7593e365cbcb44ac54306a7876be.png" /><p>我们按“y”键，然后按Enter键。我们可以使用ls检查文件是否已创建。</p><code>ls one two three</code><img class="content_img" src="/image/68/68d84f4594a7a3bdf7938c081e7cb331.png" /><p>将xargs与多个命令一起使用</p><p>通过使用-i命令(初始参数)选项，我们可以将多个命令与xargs一起使用。</p><p>此选项定义“替换字符串”。只要命令行中出现替换字符串的标记，就会插入提供给xargs的值。</p><p>让我们使用tree命令来查看当前目录中的子目录。-d(目录)选项导致树忽略文件，仅报告目录。</p><code>tree -d</code><img class="content_img" src="/image/3f/3fc85ba6f8a16b21d4de8d86b8c98257.png" /><p>只有一个名为“images”的子目录。</p><p>在名为“directories.txt”的文件中，我们有一些希望创建的目录的名称。我们可以用cat查看它的内容。</p><code>cat directories.txt</code><img class="content_img" src="/image/76/76886399ebc29946402da3f1305f66b9.png" /><p>我们将使用它作为xargs的输入数据。我们要执行的命令是：</p><code>cat directories.txt | xargs -I % sh -c 'echo %; mkdir %'</code><p>这段代码如下所示：</p><p>
cat directories.txt|：这会将directrories.txt文件的内容(所有新目录名)推送到xargs中。
xargs-i%：这定义了一个带有标记“%”的“替换字符串”。
sh-c：这将启动一个新的子shell。c(命令)告诉shell从命令行读取命令。
‘Echo%；mkdir%’：每个“%”标记都将被由xargs传递的目录名替换。echo命令将打印目录名；mkdir命令将创建目录。</p><img class="content_img" src="/image/8f/8f129c054aca6c57bd06eb7ad446abbc.png" /><p>目录逐一列出。</p><img class="content_img" src="/image/ae/ae3d2188ec5d433b8d788e666b8c74f0.png" /><p>我们可以再次使用TREE来验证目录是否已创建。</p><code>tree -d</code><img class="content_img" src="/image/9f/9f1df0b516240e2ede8e8b3e3281e5b6.png" /><p>将文件复制到多个位置</p><p>我们可以使用xargs使用单个命令将文件复制到多个位置。</p><p>我们将通过管道将两个目录的名称传递到xargs中，作为输入参数。我们将告诉xargs一次只将这些参数中的一个传递给它正在使用的命令。</p><p>在本例中，命令是cp。因此，效果是调用cp两次，每次都使用两个目录中的一个作为命令行参数。允许这种情况发生的xargs参数是-n(最大数量)选项。我们要把这件事定为一件。</p><p>我们还将-v(详细)选项与cp一起使用，以便它报告正在发生的事情。</p><code>echo ~/Backups/ ~/Documents/page-files/ | xargs -n 1 cp -v ./*.page</code><img class="content_img" src="/image/6e/6e3c672db66ffaca309809ceebc96a92.png" /><p>文件将复制到这两个目录，一次复制一个目录。CP报告每个文件复制操作，以便我们可以看到它们正在发生。</p><img class="content_img" src="/image/c1/c137090e114cd313e8d3357e65bc11d3.png" /><p>删除嵌套目录中的文件</p><p>如果文件名中包含空格和陌生字符-例如换行符-xargs将无法正确解释它们。我们可以通过使用-0(空终止符)选项来解决这个问题。这告诉xargs使用空字符作为文件名的最后分隔符。</p><p>在本例中，我们将使用find。Find有自己的选项来处理文件名中的空格和陌生字符。它是-print0(全名，空字符)选项。</p><code>find . -name "*.png" -type f -print0 | xargs -0 rm -v -rf "{}"</code><p>这段代码如下所示：</p><p>
找到。-name“*.png”：find将从当前目录搜索“。”用于名称与“*.png”匹配且为文件(type-f)的对象。
-Print0：名称将以空字符结尾，并支持空格和陌生字符。
xargs-0：xargs还会认为文件名以空结尾，空格和陌生字符不会造成问题。
rm-v-rf“{}”：rm将非常详细，并报告正在发生的情况(-v)。它将是递归的(-r)并查看嵌套子目录，并且将在不提示(-f)的情况下删除文件。“{}”替换为每个文件名。</p><img class="content_img" src="/image/1f/1fb0efd2515c6cd9dfab926607f2eacd.png" /><p>搜索所有子目录，并删除与搜索模式匹配的文件。</p><img class="content_img" src="/image/f7/f7de309ea8c8e4472120d4d05e8c6cf1.png" /><p>正在删除嵌套目录</p><p>假设我们想要删除一组嵌套子目录。树会让我们看到它们的。</p><code>tree -d</code><img class="content_img" src="/image/02/02edb4cb035cdda0f5fedb7acabc5f12.png" /><code>find . -name "level_one" -type d printo | xargs -o rm -v -rf "{}"</code><p>此命令将使用find递归地在当前目录中搜索。搜索目标是名为“LEVEL_ONE”的目录。所有目录名通过xargs传递到rm。</p><img class="content_img" src="/image/65/65674c325a28ea5dae3362340cb24456.png" /><p>此命令与前一个命令之间唯一重要的变化是，搜索项是最顶层目录的名称，并且-type d告诉find查找目录，而不是文件。</p><img class="content_img" src="/image/ec/ec934ba7bf30fa2c10a334df8f6853a3.png" /><p>每个目录的名称在删除时都会打印出来。我们可以向TREE查询：</p><code>tree -d</code><img class="content_img" src="/image/19/19695e7372fdfaa47b723e57b019cb5b.png" /><p>所有嵌套的子目录都将被删除。</p><p>删除除一种文件类型之外的所有文件</p><p>我们可以使用find、xargs和rm删除除要保留的一种类型之外的所有文件。这有点违反直觉，但是我们提供了我们想要保留的文件类型的名称，而不是我们想要删除的文件类型的名称。</p><p>-not选项告诉find返回与搜索模式不匹配的文件名。我们再次对xargs使用-i选项(初始参数)。这次我们定义的替换字符串令牌是“{}”。这将与我们之前生成的替换字符串令牌的行为完全相同，该令牌恰好是一个“%”。</p><code>find . -type f -not - name "*.sh" -print0 | xargs -0 -I {} rm -v {}</code><img class="content_img" src="/image/82/821af71ce497539a976c91d592aa5371.png" /><p>我们可以和ls核实一下。目录中只剩下与“*.sh”搜索模式匹配的文件。</p><code>ls -l</code><img class="content_img" src="/image/97/97d1b1ec6f44ec54e26dbda1b6930c4b.png" /><p>使用Xargs创建存档文件</p><p>我们可以使用find来搜索文件，并将它们传递给到tar的xargs，以创建一个归档文件。</p><p>我们将在当前目录中进行搜索。搜索模式是“*.page”，因此我们将查找“.page”文件。</p><code>find ./ - name "*.page" -type f -print0 | xargs -0 -tar -cvzf page_files.tar.gz</code><img class="content_img" src="/image/2a/2a6677701aeb7f7da8567c2412d14b7c.png" /><p>创建存档文件时，文件会按预期列出。</p><img class="content_img" src="/image/d1/d1579a1066ad726dd933d81018162430.png" /><p>数据调解器</p><p>有时候，当你把东西堆放在一起的时候，你需要一些脚手架。xargs弥合了可以输出信息的命令和不能接收信息的命令之间的差距。</p><p>xargs和find都有大量的选项。我们鼓励您查看他们的手册页以了解更多信息。</p><div class="item_info"><span class="item_key"><a href="/tag/xargs/">xargs</a></span><span class="item_key"><a href="/tag/命令/">命令</a></span><span class="item_key"><a href="/tag/文件/">文件</a></span></div></div></div><div id="footer">&copy 2020 fuzadu.com</div></body></html>