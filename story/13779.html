<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何在Linux上使用rev命令</title><link rel="stylesheet" href="/css.css"></head><body><div id="header"><a class="site_title" href="http://www.fuzadu.com">复杂度</a></div><div><div><h2>如何在Linux上使用rev命令</h2></div><div class="content"><p>Linux的rev命令反转文本字符串。该命令可以对提供的文本或文件进行操作，而且看起来非常简单。但与许多命令行实用程序一样，当您将其与其他命令结合使用时，它的真正功能就会显现出来。</p><p>rev命令是那些简单的Linux实用程序之一，乍一看似乎有些奇怪。它执行单一功能：颠倒字符串。除了能够打印快速帮助页(-h)并向您显示其版本号(-V)之外，它不接受任何命令行选项。</p><p>所以，雷夫颠倒了弦，就这样？没有变体或选项吗？是也不是。是的，它没有排列，但不，这还不是全部。本教程将向您展示如何将其组合以实现强大的操作。</p><p>当您在更复杂的命令序列中使用rev*作为构建块时，它真的开始显示出它的价值。rev是一组充当促进器的命令(如ttac和yes)中的一个。当您看到它们如何更有效地使用其他命令时，就更容易理解它们的用处。</p><p>使用rev命令</p><p>rev在不带其他参数的命令行上使用，它接受任何键入的输入，反转它，然后在终端窗口中打印它。它会一直这样做，直到您按下Ctrl+C退出。</p><code>rev</code><img class="content_img" src="/image/67/67f9322573bd37d855308b88c474236d.png" /><p>如果您键入一些文本并按Enter键，就会让rev反向打印字符串-当然，除非您为它提供了回文。</p><img class="content_img" src="/image/e2/e2cf4e4ac9bf3d43b6061ba0ffc136f9.png" /><p>将文本传递到版本</p><p>您可以使用ECHO将文本通过管道传送到Rev.</p><code>echo one two three | rev</code><img class="content_img" src="/image/56/561a3d07e454aaf9fd4311af7b5c89b6.png" /><p>您还可以使用rev逐行反转整个文本文件的内容。在本例中，我们有一个包含文件名列表的文件。该文件名为“filelist.txt”。</p><code>rev filelist.txt</code><img class="content_img" src="/image/1a/1ad16d0aa1fd60f02cf1e5d0fcc90c5e.png" /><p>从文件中读取每一行，反转，然后打印到终端窗口。</p><p>将rev与其他命令组合使用</p><p>下面是一个使用管道输入的示例，该管道调用rev两次。</p><p>此命令将文本字符串中的最后一个字符去掉。这对于删除标点符号可能很有用。我们需要使用Cut命令来剥离角色。</p><code>echo 'Remove punctuation.' | rev | cut -c 2- | rev</code><img class="content_img" src="/image/d9/d9ac86a71cd441ce84e36702c8641727.png" /><p>我们来分析一下。</p><p>
Echo将字符串发送到对Rev.。
REV将字符串反转，并通过管道将其插入CUT。
c(字符)选项告诉Cut返回字符串中的字符序列。
2-选项告诉Cut返回从字符2到行尾的字符范围。如果提供第二个数字，如2-5，则范围为2到5个字符。没有第二个数字表示“一直到字符串的末尾”。
反转的字符串-减去它的第一个字符-被传递给rev，后者反转字符串，因此它回到了原来的顺序。</p><p>因为我们去掉了反转字符串的第一个字符，所以我们去掉了原始字符串的最后一个字符。是的，您可以使用sed或awk来实现这一点，但这是一种更简单的语法。</p><p>分隔最后一个单词</p><p>我们可以使用类似的技巧来返回该行的最后一个单词。</p><p>该命令与最后一个命令类似：同样，它使用了两次rev。不同之处在于使用CUT命令选择文本部分的方式。</p><code>echo 'Separate the last word' | rev | cut -d' ' -f1 | rev</code><img class="content_img" src="/image/da/dab64c74cfd6c38ed23333a0f6ece600.png" /><p>以下是命令明细：</p><p>
Echo将字符串发送到对Rev.。
REV将字符串反转，并通过管道将其插入CUT。
-d‘’选项(分隔符)告诉Cut返回由空格分隔的字符序列。
f1选项告诉Cut返回不包含分隔符的字符串的第一部分。换句话说，句子的第一部分一直到第一个空格。
颠倒的第一个单词被传递给rev，rev颠倒字符串，因此它回到了原来的顺序。</p><p>因为我们提取了颠倒的字符串的第一个单词，所以我们去掉了原始字符串的最后一个单词。这句话的最后一个词是“word”，它是为我们打印出来的。</p><p>修剪文件中的内容</p><p>假设我们有一个包含文件名列表的文件，文件名用引号引起来。我们想把文件名中的引号去掉。</p><p>我们来看一下这个文件：</p><code>less filelist.txt</code><img class="content_img" src="/image/30/301dc1e2306a370908a17ef69fb8b8e4.png" /><p>文件的内容以更少的篇幅显示给我们。</p><img class="content_img" src="/image/cc/cc8d20970669aac0e3a98fbf2f5b6e21.png" /><p>我们可以使用以下命令删除每行两端的标点符号。此命令使用两次版本号和版本号两次。</p><code>rev filelist.txt | cut -c 2- | rev | cut -c 2-</code><img class="content_img" src="/image/f4/f49bdee575b161bc714d3fbf05126f22.png" /><p>为我们列出的文件名不带引号。</p><img class="content_img" src="/image/f7/f7596c83cb91bd8b8a6bfa68086e67b8.png" /><p>该命令按如下方式分解：</p><p>
Rev反转文件中的行，并将它们通过管道传输到CUT。
c(字符)选项告诉CUT从每行返回一个字符序列。
2-选项告诉Cut返回从字符2到每行末尾的字符范围。
反转的字符串减去它们的第一个字符，将传递给Rev.。
Rev颠倒了字符串，所以它们又回到了原来的顺序。他们被送到第二次切割。
c(字符)选项告诉CUT从每个字符串返回一个字符序列。
2-选项告诉Cut返回从字符2到每行末尾的字符范围。这“跳过”前导引号，即每行一个字符。</p><p>很多管道</p><p>下面的命令返回当前目录中每个文件扩展名的排序列表。它使用五个不同的Linux命令。</p><code>ls | rev | cut -d'.' -f1 | rev | sort | uniq</code><img class="content_img" src="/image/8c/8c3261d329b76a87de124a59b14c8c7b.png" /><p>这个过程很简单：</p><p>
ls-列出当前目录中的文件。这些被输送到Rev.。
REV反转文件名并将它们通过管道传输到CUT。
CUT返回每个文件名的第一部分，直到分隔符。-d‘.’告诉Cut使用句点“。作为分隔符。直到第一个句点的反转文件名部分是文件扩展名。这些被输送到Rev.。
REV将文件扩展名反转为其原始顺序。他们被用管子分门别类。
排序对文件扩展名进行排序，并将结果通过管道传输到uniq。
Uniq为每种类型的唯一文件扩展名返回单个列表。注意：如果没有文件扩展名(例如Makefile以及目录help和gc_help)，则会列出整个文件名。</p><p>要对其进行最后的润色，请将-c(Count)命令行选项添加到uniq命令。</p><code>ls | rev | cut -d'.' -f1 | rev | sort | uniq -c</code><img class="content_img" src="/image/f9/f9277c983f5e7ef18f9c772fdc145aca.png" /><p>我们现在得到当前目录中不同文件类型的排序列表，每个类型的计数都是。</p><p>这是一句相当漂亮的俏皮话！</p><p>DrakcaB gnioG的DrawroF或DrakcaB gnioG</p><p>有时你必须后退才能前进。作为团队的一员，你通常前进得最快。</p><p>将rev添加到您的所有转到命令中，您很快就会使用它来简化原本复杂的命令序列。</p><div class="item_info"><span class="item_key"><a href="/tag/命令/">命令</a></span><span class="item_key"><a href="/tag/rev/">rev</a></span><span class="item_key"><a href="/tag/使用/">使用</a></span></div></div><div class="relate_story"><div><h3>相关文章</h3></div><ul><li><a href="/story/14507.html">如何在Linux上使用HISTORY命令</a><li><a href="/story/14466.html">如何在Linux上使用at和Batch来调度命令</a><li><a href="/story/14448.html">如何在Linux上使用Which命令</a><li><a href="/story/14302.html">如何在Linux上使用Echo命令</a><li><a href="/story/14121.html">如何在Linux上使用chroot命令</a><li><a href="/story/14091.html">如何在Linux上运行和控制后台进程</a><li><a href="/story/14037.html">如何在Linux上创建别名和Shell函数</a><li><a href="/story/14013.html">Bash你需要知道的15个特殊字符</a><li><a href="/story/14001.html">如何在Linux上使用管道</a><li><a href="/story/13823.html">如何在Linux上使用xargs命令</a><li><a href="/story/13739.html">如何监控Linux命令的进度(使用pv和Progress)</a><li><a href="/story/13621.html">如何从Linux终端列出您的计算机设备</a><li><a href="/story/13610.html">如何使用Linux type命令</a><li><a href="/story/13585.html">如何使用Linux的所有搜索命令</a><li><a href="/story/13474.html">如何在Linux上使用重命名命令</a><li><a href="/story/13312.html">如何从Linux终端杀死进程</a><li><a href="/story/13258.html">37个您应该知道的重要Linux命令</a><li><a href="/story/13253.html">如何使用命令行重新启动或关闭Linux</a><li><a href="/story/13218.html">如何在Linux上使用“Install”命令复制文件</a><li><a href="/story/13196.html">如何更改默认的crontab编辑器</a></ul></div></div><div id="footer">&copy 2020 fuzadu.com</div></body></html>