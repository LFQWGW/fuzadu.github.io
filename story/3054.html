<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何在Ubuntu中调整您的固态硬盘以获得更好的性能</title><link rel="stylesheet" href="/css.css"><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?f75329719d379998b2421a4cc2396366";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="header"><a class="site_title" href="http://www.fuzadu.com">复杂度</a></div><div><div><h2>如何在Ubuntu中调整您的固态硬盘以获得更好的性能</h2></div><div class="content"><img class="content_img" src="/image/70/7033a2c81d582fd055517894d1a26ccb.png" /><p>在Linux上调整你的SSD有很多小贴士，还有很多关于什么能用什么不能用的轶事报道。我们运行了我们自己的基准测试，做了一些具体的调整，向你展示了真正的不同之处。</p><p>基准</p><p>为了对我们的磁盘进行基准测试，我们使用了Phoronix测试套件。它是免费的，并且有一个针对Ubuntu的存储库，因此您不必从头开始编译来运行快速测试。在全新安装64位Ubuntu Natty之后，我们使用ext4文件系统的默认参数测试了我们的系统。</p><img class="content_img" src="/image/03/03e1d81a5ecc56df5782071fa8ea8c2c.png" /><p>我们的系统规格如下：</p><p>
AMD Phenom II四核@3.2 GHz。
MSI 760GM E51主板。
3.5 GB RAM。
集成AMD RADEON 3000，带512MB RAM。
Ubuntu Natty</p><p>当然，我们用来测试的固态硬盘是一个64 GB的OCZ Onyx驱动器(撰写本文时，Amazon.com上的售价为117美元)。</p><p>突出的调整</p><p>在升级到SSD时，人们推荐了相当多的更改。在过滤掉一些较旧的内容之后，我们列出了Linux发行版没有包含在SSD默认设置中的一些调整。其中三个涉及编辑fstab文件，因此请在继续执行以下命令之前进行备份：</p><p>如果出现问题，您可以随时删除新的fstab文件，并将其替换为备份的副本。如果你不知道那是什么，或者你想复习一下它是如何工作的，看看HTG解释：什么是Linux fstab，它是如何工作的？</p><p>避免访问时间</p><p>您可以通过减少操作系统写入磁盘的数量来帮助延长固态硬盘的使用寿命。如果需要知道上次访问每个文件或目录的时间，可以将以下两个选项添加到/etc/fstab文件中：</p><p>将它们与其他选项一起添加，并确保它们都用逗号分隔，没有空格。</p><img class="content_img" src="/image/6a/6a0115b79c611198674a3a2cc54a6e9c.png" /><p>启用修剪</p><p>您可以启用Trim来帮助管理长期的磁盘性能。将以下选项添加到您的fstab文件：</p><p>这对于ext4文件系统非常有效，甚至在标准硬盘上也是如此。您的内核版本必须至少为2.6.33或更高版本；如果您使用的是Maverick或Natty，或者在Lucid上启用了后端口，则会受到保护。虽然这并没有特别改善最初的基准测试，但从长远来看，它应该会使系统表现得更好，所以它列在了我们的列表中。</p><p>Tmpfs</p><p>系统缓存存储在/tmp中。我们可以告诉fstab将其作为临时文件系统挂载到RAM中，这样您的系统对硬盘的接触就会更少。将以下行添加到/etc/fstab文件的底部的新行中：</p><p>保存您的fstab文件以提交这些更改。</p><p>切换IO调度器</p><p>您的系统不会立即将所有更改写入磁盘，并且多个请求会排队。默认的输入-输出调度器-CFQ-可以很好地处理这一问题，但我们可以将其更改为更适合我们的硬件的调度器。</p><p>首先，列出您可以使用以下命令的选项，用根驱动器的盘符替换“X”：</p><p>我的安装在SDA上。您应该会看到几个不同的选项。</p><img class="content_img" src="/image/bf/bfbaf1b41820c67c7b1e053bfa51ce52.png" /><p>如果你有最后期限，你应该使用它，因为它会给你一个额外的调整。如果没有，您应该能够使用noop而不会出现问题。我们需要告诉操作系统在每次引导后使用这些选项，因此我们需要编辑rc.local文件。</p><p>我们将使用Nano，因为我们熟悉命令行，但是您可以使用您喜欢的任何其他文本编辑器(gedit、vim等)。</p><p>如果您使用的是Deadline，请在“Exit 0”行上方添加以下两行：</p><p>如果您使用的是noop，请添加以下行：</p><p>再次将“X”替换为适合您安装的驱动器号。把每件东西都检查一遍，以确保它看起来很好。</p><img class="content_img" src="/image/9f/9f5a8b86c9f12cdcbccf622c6333516d.png" /><p>然后，按CTRL+O保存，然后按CTRL+X退出。</p><p>重新开始，重新启动</p><p>要使所有这些更改生效，您需要重新启动。在那之后，你应该都准备好了。如果出现问题并且无法引导，您可以系统地撤消上述每个步骤，直到可以再次引导为止。如果您愿意，您甚至可以使用LiveCD或LiveUSB进行恢复。</p><p>您的fstab更改将贯穿安装的整个生命周期，即使是升级，但您的rc.local更改必须在每次升级(版本之间)后重新生效。</p><p>基准测试结果</p><p>为了执行基准测试，我们运行了磁盘测试套件。每个测试的顶部映像是在调整ext4配置之前，而底部映像是在调整和重启之后。您将看到测试度量内容的简要说明以及对结果的解释。</p><p>大文件操作</p><img class="content_img" src="/image/d3/d329a502286e8451af2b4c4b1f2e4dfe.png" /><img class="content_img" src="/image/e3/e31558f582278da40ffe75a7acb2dcb6.png" /><p>此测试使用随机数据压缩一个2 GB的文件，并将其写入磁盘。这里的SSD调整显示改进了大约40%。</p><img class="content_img" src="/image/b4/b4dfb2d376b802b1748d9c68f7dc50ee.png" /><img class="content_img" src="/image/47/47a51c39bced80b7b721143169b6dfe0.png" /><p>IOzone模拟文件系统性能，在本例中通过写入8 GB文件。又一次，几乎增加了50%。</p><img class="content_img" src="/image/15/15181a640f048f45fb3b10ca75b5d737.png" /><img class="content_img" src="/image/b2/b2c24954057fd2a28399ee099457c2c8.png" /><p>在这里，读取了一个8 GB的文件。结果与没有调整ext4的结果几乎相同。</p><img class="content_img" src="/image/2f/2fb3a8de7008696476bdffcc2b551ae2.png" /><img class="content_img" src="/image/6b/6bb9603a2048f130208c6c499725f4df.png" /><p>AIO-Stress使用2 GB的测试文件和64KB的记录大小异步测试输入和输出。在这里，与普通的ext4相比，性能几乎提高了200%！</p><p>小文件操作</p><img class="content_img" src="/image/a4/a4993c27eba31e9baed4f2d3166c3a8b.png" /><img class="content_img" src="/image/9f/9f3a950d360335536e2cf1bc14eafe1b.png" /><p>创建了一个SQLite数据库，PTS向其中添加了12，500条记录。这里的SSD调整实际上降低了大约10%的性能。</p><img class="content_img" src="/image/e2/e2c7586d7b56c7bb9590a0a5992f5932.png" /><img class="content_img" src="/image/92/923ead6808fc2274866ea51991eed9e7.png" /><p>Apache基准测试小文件的随机读取。优化我们的固态硬盘后，性能提升了约25%。</p><img class="content_img" src="/image/b8/b88a752380f5d58a8d603d30e671efaf.png" /><img class="content_img" src="/image/ac/ac406118fa447821611b0d5329fd5f78.png" /><p>Postmark模拟25，000个文件事务，其中500个在任何给定时间同时进行，文件大小在5到512KB之间。这很好地模拟了Web和邮件服务器，我们看到调整后性能提高了16%。</p><img class="content_img" src="/image/55/5544fb6ccebc3db2fc69f3db014f7970.png" /><img class="content_img" src="/image/e7/e7c646c423739af308609eabbd47a80c.png" /><p>FS-Mark查看1000个文件，总大小为1MB，并测量在预定时间内可以完全写入和读取多少个文件。我们的调整再次看到，文件大小较小时会有所增加。经过ext4调整后大约增加了45%。</p><p>文件系统访问</p><img class="content_img" src="/image/c4/c41aeeffe5fc59fcfbcedb4a2bc91721.png" /><img class="content_img" src="/image/9b/9b7d763047c0036d769edb6925d27c97.png" /><p>Dbench基准测试客户端的文件系统调用，类似于Samba的工作方式。在这里，vanilla ext4的性能降低了75%，这是我们所做更改中的一个重大挫折。</p><img class="content_img" src="/image/48/4804b7798dcfd922db5c7f4c7bf7b60a.png" /><img class="content_img" src="/image/42/42f5be896d00fa184913de2591434abc.png" /><p>您可以看到，随着客户端数量的增加，性能差异也会增大。</p><img class="content_img" src="/image/ee/eedddce959c8d0b73a78974909d8278c.png" /><img class="content_img" src="/image/e5/e5c59e19c93370fdbfce680d10501a32.png" /><p>有了48个客户端，两者之间的差距有所缩小，但我们的调整仍然有非常明显的性能损失。</p><img class="content_img" src="/image/ff/ff2f09954e81e6d43a4e745f91ea8c2f.png" /><img class="content_img" src="/image/f8/f8f9ff5d68acc3afdfbb0d3bd3544181.png" /><p>对于128个客户端，性能几乎相同。您可以解释说，我们的调整可能不太适合这种操作中的家庭使用，但在客户端数量大幅增加时会提供相当的性能。</p><img class="content_img" src="/image/a9/a978e45e89c2558ae5423322597391f9.png" /><img class="content_img" src="/image/19/195c7927fdd8358aefdae23b79a46523.png" /><p>此测试取决于内核的AIO访问库。我们这里有20%的进步。</p><img class="content_img" src="/image/30/30346904e92aa25066be12a2dd7d4ca5.png" /><img class="content_img" src="/image/38/38ce2b855b7038a5a3efe13f5207e21c.png" /><p>在这里，我们有一个64MB的多线程随机读取，这里的性能提高了200%！哇!</p><img class="content_img" src="/image/17/170f434f828888e9be26f1ba19f4f6bb.png" /><img class="content_img" src="/image/54/54b97d84f4d5db93371e216fb2604401.png" /><p>在使用32个线程写入64MB数据的同时，我们的性能仍然提高了75%。</p><img class="content_img" src="/image/d3/d3cb9d576c647169e8f53ba722a96344.png" /><img class="content_img" src="/image/08/0847319fa96d36bbdc8e3ae8e6d5fcab.png" /><p>编译基准通过操作内核树(创建、编译、修补等)来模拟老化对文件系统的影响。在这里，您可以看到通过模拟内核的初始创建可以获得约40%的显著收益。</p><img class="content_img" src="/image/4e/4e5bd305e3008cf46fb4ec7f04b4af73.png" /><img class="content_img" src="/image/30/305dac8b5cb1e30cb0bec2afe160c22f.png" /><p>此基准测试只是测量解压Linux内核所需的时间。这里的性能没有太大的提高。</p><p>简略的 / 概括的 / 简易判罪的 / 简易的</p><img class="content_img" src="/image/d3/d35947c733f91651a5cfef082cd4618f.png" /><p>我们对Ubuntu开箱即用的ext4配置所做的调整确实产生了相当大的影响。性能提升最大的领域是多线程写入和读取、小文件读取和大型连续文件读取和写入。事实上，我们看到的唯一真正影响性能的地方是简单的文件系统调用，这是Samba用户应该注意的。总体而言，托管网页和观看/流媒体大型视频等功能的性能似乎有了相当大的提升。</p><p>请记住，这是专门针对64位Ubuntu Natty的。如果您的系统或SSD不同，您的里程数可能会有所不同。不过，总的来说，我们所做的fstab和IO调度器调整似乎对更好的性能有很大的帮助，所以可能值得在您自己的平台上尝试一下。</p><p>您有自己的基准并想要分享您的结果吗？还有另一个我们不知道的办法吗？请在评论中畅所欲言！</p><div class="item_info"><span class="item_key"><a href="/tag/性能/">性能</a></span><span class="item_key"><a href="/tag/使用/">使用</a></span><span class="item_key"><a href="/tag/测试/">测试</a></span></div></div><div class="relate_story"><div><h3>相关文章</h3></div><ul><li><a href="/story/5081.html">在Linux上使用Steam提高游戏性能的6个提示</a><li><a href="/story/4221.html">如何对您的Linux系统进行基准测试：3个开源基准测试工具</a></ul></div></div><div id="footer">&copy 2020 fuzadu.com</div></body></html>