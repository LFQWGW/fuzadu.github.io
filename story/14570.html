<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何在Linux上使用grep命令</title><link rel="stylesheet" href="/css.css"></head><body><div id="header"><a class="site_title" href="http://www.fuzadu.com">复杂度</a></div><div><div><h2>如何在Linux上使用grep命令</h2></div><div class="content"><p>Linux grep命令是一个字符串和模式匹配实用程序，可显示多个文件中的匹配行。它还可以使用来自其他命令的管道输出。我们教你怎么做。</p><p>GREP背后的故事</p><p>grep命令在Linux和Unix圈子里很有名，原因有三。首先，它非常有用。其次，丰富的选择可能是压倒性的。第三，它是在一夜之间写成的，以满足特定的需求。前两个很好，第三个稍微差一点。</p><p>肯·汤普森(Ken Thompson)从ed编辑器(发音为ee-dee)中提取了正则表达式搜索功能，并创建了一个小程序--供他自己使用--来搜索文本文件。在贝尔实验室，他的部门主管道格·麦克罗伊(Doug McIlroy)找到汤普森，描述了他的同事李·麦克马洪(Lee McMahon)面临的问题。</p><p>麦克马洪试图通过文本分析来确定联邦党论文的作者。他需要一种可以在文本文件中搜索短语和字符串的工具。那天晚上，汤普森花了大约一个小时的时间将他的工具变成一个可以被其他人使用的通用工具，并将其重命名为grep。他的名字取自ed命令字符串g/re/p，翻译过来就是“全局正则表达式搜索”。</p><p>你可以看汤普森和布莱恩·科尼根谈论GREP的诞生。</p><p>使用grep进行简单搜索</p><p>要在文件中搜索字符串，请在命令行上传递搜索项和文件名：</p><p>将显示匹配线。在本例中，它是单行。匹配的文本将突出显示。这是因为在大多数发行版中，grep别名为：</p><code>alias grep='grep --colour=auto'</code><p>让我们看一下有多行匹配的结果。我们将在应用程序日志文件中查找单词“Average”。因为我们记不起日志文件中的单词是否为小写，所以我们将使用-i(忽略大小写)选项：</p><code>grep -i Average geek-1.log</code><img class="content_img" src="/image/d0/d07f03c8bacb64d3ec11169e1e2644f4.png" /><p>将显示每个匹配的行，并在每个行中突出显示匹配的文本。</p><img class="content_img" src="/image/14/14e94c73c7eb28effb8c7fd3e6cb0982.png" /><p>我们可以使用-v(反转匹配)选项显示不匹配的行。</p><code>grep -v Mem geek-1.log</code><img class="content_img" src="/image/68/681452e7295a529c16725038323b8f57.png" /><p>没有突出显示，因为这些是不匹配的行。</p><img class="content_img" src="/image/7c/7c80650e3e0b53019a0e3fbbc21ef3bb.png" /><p>我们可以让grep完全沉默。结果作为grep的返回值传递给shell。结果为0表示找到该字符串，结果为1表示未找到该字符串。我们可以使用$？检查返回代码？特殊参数：</p><code>grep -q average geek-1.log</code><code>echo $?</code><code>grep -q howtogeek geek-1.log</code><code>echo $?</code><img class="content_img" src="/image/40/40037a0514f59ea971680338537a14fd.png" /><p>使用grep进行递归搜索</p><p>要搜索嵌套目录和子目录，请使用-r(递归)选项。请注意，您没有在命令行上提供文件名，您必须提供路径。在这里，我们在当前目录中进行搜索“。以及任何子目录：</p><code>grep -r -i memfree .</code><img class="content_img" src="/image/f4/f43ebdc449918edce90b43f857c5c876.png" /><p>输出包括每个匹配行的目录和文件名。</p><img class="content_img" src="/image/48/48e461c72e46edc43292802031ac148e.png" /><p>我们可以使用-R(递归取消引用)选项使grep跟随符号链接。我们在此目录中有一个符号链接，名为logs-Folder。它指向/home/dave/logs。</p><code>ls -l logs-folder</code><img class="content_img" src="/image/44/44b5de1285fe19cc3ebc039cb3e5f243.png" /><p>让我们使用-R(递归取消引用)选项重复上次搜索：</p><code>grep -R -i memfree .</code><img class="content_img" src="/image/03/03557b194fb8b2b7eb0d1b4c2962e164.png" /><p>跟随符号链接，grep也搜索它所指向的目录。</p><img class="content_img" src="/image/4e/4eee355d35d86e984a717d23ebdbe589.png" /><p>搜索整个单词</p><p>默认情况下，如果搜索目标出现在该行中的任何位置(包括在另一个字符串中)，grep将与该行匹配。看看这个例子。我们要搜索“自由”这个词。</p><code>grep -i free geek-1.log</code><img class="content_img" src="/image/95/95a547646c4982e8b732dc4c32890930.png" /><p>结果是包含字符串“free”的行，但它们不是单独的单词。它们是字符串“MemFree”的一部分。</p><img class="content_img" src="/image/1f/1fca9e7cddbee0bcf0a681e4c2b7307c.png" /><p>要强制grep命令仅匹配单独的“word”，请使用-w(Word Regexp)选项。</p><code>grep -w -i free geek-1.log</code><code>echo $?</code><img class="content_img" src="/image/b1/b10d39368abdde7182c01ecd9334143e.png" /><p>这一次没有结果，因为搜索词“free”没有作为单独的单词出现在文件中。</p><p>使用多个搜索词</p><p>-E(扩展regexp)选项允许您搜索多个单词。(-E选项取代了不推荐使用的egrep版本的grep。)</p><p>该命令搜索两个搜索词“Average”和“memfree”。</p><code>grep -E -w -i "average|memfree" geek-1.log</code><img class="content_img" src="/image/c6/c6678b819677f388833258d23243e640.png" /><p>显示每个搜索词的所有匹配行。</p><img class="content_img" src="/image/93/931beef5c1c8069ab2bc1e3f21210505.png" /><p>您还可以搜索多个词条，这些词条不一定是完整的单词，但也可以是完整的单词。</p><p>e(模式)选项允许您在命令行上使用多个搜索词。我们使用正则表达式括号功能来创建搜索模式。它告诉grep匹配方括号“[]”中包含的任何一个字符。这意味着grep在搜索时将匹配“kB”或“KB”。</p><img class="content_img" src="/image/d1/d12039fab88d5e4b54610227482927c4.png" /><p>两个字符串都匹配，实际上，有些行同时包含这两个字符串。</p><p>完全匹配的行</p><p>-x(行regexp)将只匹配整行与搜索词匹配的行。让我们搜索已知在日志文件中只出现一次的日期和时间戳：</p><code>grep -x "20-Jan--06 15:24:35" geek-1.log</code><img class="content_img" src="/image/ea/eaabda9eae20dc0a28cf33f2a667a2c7.png" /><p>找到并显示匹配的单行。</p><p>与之相反的是，只显示不匹配的行。这在您查看配置文件时会很有用。评论很棒，但有时很难在所有评论中找出实际设置。以下是/etc/sudoers文件：</p><img class="content_img" src="/image/6a/6abe04174eecbe6c3a953fc1d7ea064b.png" /><p>我们可以有效地过滤出评论行，如下所示：</p><code>sudo grep -v "#" /etc/sudoers</code><img class="content_img" src="/image/13/1376113d31c3945e132f236683172d37.png" /><p>这就更容易解析了。</p><p>仅显示匹配文本</p><p>有时您可能不想看到整个匹配的行，只想看到匹配的文本。o(唯一匹配)选项就是这样做的。</p><code>grep -o MemFree geek-1.log</code><img class="content_img" src="/image/9c/9c8206219d8b9ea2eab8d0b9169de142.png" /><p>显示减少到只显示匹配搜索词的文本，而不是显示整个匹配行。</p><img class="content_img" src="/image/ac/ac3f91d5e7e5c064682473e118890749.png" /><p>使用grep进行计数</p><p>grep不仅仅是文本，它还可以提供数字信息。我们可以用不同的方式让grep为我们服务。如果我们想知道一个搜索词在一个文件中出现了多少次，可以使用-c(计数)选项。</p><code>grep -c average geek-1.log</code><img class="content_img" src="/image/15/155d36225231613008a4ab9f68e989f2.png" /><p>grep报告该搜索词在此文件中出现了240次。</p><p>您可以使用-n(行号)选项让grep显示每个匹配行的行号。</p><code>grep -n Jan geek-1.log</code><img class="content_img" src="/image/85/85f7288889cc3e706cea65b3f9c0234c.png" /><p>每条匹配行的行号显示在该行的开头。</p><img class="content_img" src="/image/1e/1e9beeed405e27c3232d15cfc1f3d7c6.png" /><p>要减少显示的结果数，请使用-m(最大计数)选项。我们将把输出限制为五个匹配的行：</p><code>grep -m5 -n Jan geek-1.log</code><img class="content_img" src="/image/16/16359d95a294de5b4568b8b4663ce25e.png" /><p>添加上下文</p><p>能够看到每个匹配行的一些附加行(可能是不匹配的行)通常很有用。它可以帮助区分哪些匹配的行是您感兴趣的。</p><p>要显示匹配行之后的一些行，请使用-A(上下文之后)选项。在本例中，我们要求三行代码：</p><code>grep -A 3 -x "20-Jan-06 15:24:35" geek-1.log</code><img class="content_img" src="/image/54/5477f9cc2049f8472fcea79b2f8469ad.png" /><p>要查看匹配行之前的一些行，请使用-B(之前的上下文)选项。</p><code>grep -B 3 -x "20-Jan-06 15:24:35" geek-1.log</code><img class="content_img" src="/image/9c/9c49cb94e84ab99f9f305827fe192d46.png" /><p>要包括匹配行之前和之后的行，请使用-C(上下文)选项。</p><code>grep -C 3 -x "20-Jan-06 15:24:35" geek-1.log</code><img class="content_img" src="/image/e1/e172f600821858f38ee6c68becff9d71.png" /><p>显示匹配的文件</p><p>要查看包含搜索词的文件名，请使用-l选项(匹配的文件)。要找出哪些C源代码文件包含对sl.h头文件的引用，请使用以下命令：</p><code>grep -l "sl.h" *.c</code><img class="content_img" src="/image/b2/b2ef4312a966bb853bcfe3ffcdd55438.png" /><p>列出的是文件名，而不是匹配的行。</p><img class="content_img" src="/image/5b/5b1b0d58cc0a6be47ca2bb0f3c32dce4.png" /><p>当然，我们可以查找不包含搜索词的文件。-L(不匹配的文件)选项就是这样做的。</p><code>grep -L "sl.h" *.c</code><img class="content_img" src="/image/d1/d19c341c313d166d23d6df5e3cf3ce98.png" /><p>线的起点和终点</p><p>我们可以强制grep只显示行首或行尾的匹配项。“^”正则表达式运算符与行的开头匹配。实际上，日志文件中的所有行都将包含空格，但我们将搜索第一个字符为空格的行：</p><code>grep "^ " geek-1.log</code><img class="content_img" src="/image/2d/2d9c93948c26aabb8094c439713cb788.png" /><p>在行首显示以空格作为第一个字符的行。</p><img class="content_img" src="/image/55/554a58437613160689b6cab8ec82e962.png" /><p>要匹配行尾，请使用“$”正则表达式运算符。我们将搜索以“00”结尾的行。</p><code>grep "00$" geek-1.log</code><img class="content_img" src="/image/fb/fba19ae182d88516ef9d4c4cf6eb3630.png" /><p>显示屏显示以“00”作为最后字符的行。</p><img class="content_img" src="/image/da/dacaaca0fddab21d77c0f826313d262c.png" /><p>将管道与grep一起使用</p><p>当然，您可以将输入通过管道传输到grep，将grep的输出通过管道传输到另一个程序，并将grep置于管道链的中间。</p><p>假设我们希望看到字符串“ExtractParameters”在C源代码文件中的所有匹配项。我们知道将会有相当多的输出，所以我们通过管道将输出分成较少的部分：</p><code>grep "ExtractParameters" *.c | less</code><img class="content_img" src="/image/76/76baa6dd38670a7ddbfe534c2a97e870.png" /><p>输出是以LESS格式显示的。</p><img class="content_img" src="/image/1a/1a7f81c6a20d0bafffbdcd8d1b3e5633.png" /><p>这使您可以浏览文件列表并使用Less的搜索功能。</p><p>如果我们通过管道将grep的输出传输到wc，并使用-l(行)选项，我们就可以计算源代码文件中包含“ExtractParameters”的行数。(我们可以使用grep-c(Count)选项来实现这一点，但这是演示从grep输出管道的一种很好的方式。)</p><code>grep "ExtractParameters" *.c | wc -l</code><img class="content_img" src="/image/be/be5a5274b17c83eea5d728be9224e6ee.png" /><p>使用下一个命令，我们将通过管道将ls的输出传输到grep，并将来自grep的输出传输到排序。我们将列出当前目录中的文件，选择其中包含字符串“aug”的文件，并根据文件大小对它们进行排序：</p><code>ls -l | grep "Aug" | sort +4n</code><img class="content_img" src="/image/0e/0ed29557de299f5ab4e7f6b427115203.png" /><p>让我们来分析一下这一点：</p><p>
ls-l：使用ls执行文件的长格式列表。
grep“aug”：从ls清单中选择带有“aug”的行。请注意，这还会查找名称中包含“aug”的文件。
SORT+4N：在第四列(文件大小)上对grep的输出进行排序。</p><p>我们得到8月份修改过的所有文件的排序列表(与年份无关)，按文件大小升序排列。</p><p>相关：如何在Linux上使用管道</p><p>格雷普：与其说是命令，不如说是盟友</p><p>grep是一个非常适合您使用的工具。它可以追溯到1974年，现在仍然很强大，因为我们需要它所做的事情，没有什么比它做得更好了。</p><p>将grep与一些正则表达式相结合-fu真的将它带到了一个新的层次。</p><p>相关：如何使用基本正则表达式更好地搜索并节省时间</p><div class="item_info"><span class="item_key"><a href="/tag/grep/">grep</a></span><span class="item_key"><a href="/tag/使用/">使用</a></span><span class="item_key"><a href="/tag/匹配/">匹配</a></span></div></div></div><div id="footer">&copy 2020 fuzadu.com</div></body></html>