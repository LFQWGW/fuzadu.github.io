<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Linux上的stdin、stdout和stderr是什么？</title><link rel="stylesheet" href="/css.css"></head><body><div id="header"><a class="site_title" href="http://www.fuzadu.com">复杂度</a></div><div><div><h2>Linux上的stdin、stdout和stderr是什么？</h2></div><div class="content"><p>stdin、stdout和stderr是启动Linux命令时创建的三个数据流。您可以使用它们来判断您的脚本是否正在被管道传输或重定向。我们教你怎么做。</p><p>溪流汇合两点</p><p>一旦你开始学习Linux和类似Unix的操作系统，你就会遇到术语stdin、stdout和stederr。这是在执行Linux命令时建立的三个标准流。在计算中，流是可以传输数据的东西。在这些流的情况下，该数据是文本。</p><p>数据流和水流一样，有两个末端。他们有一个源头和一个外流。无论您使用哪个Linux命令，都会提供每个流的一端。另一端由启动该命令的shell确定。根据启动命令的命令行，该端将连接到终端窗口、连接到管道或重定向到文件或其他命令。</p><p>Linux标准流</p><p>在Linux中，stdin是标准输入流。它接受文本作为其输入。命令到shell的文本输出通过stdout(标准输出)流传递。来自命令的错误消息通过stderr(标准错误)流发送。</p><p>因此，您可以看到有两个输出流stdout和stderr，以及一个输入流stdin。因为错误消息和正常输出都有自己的管道将它们传送到终端窗口，所以它们可以相互独立地处理。</p><p>流的处理方式与文件类似</p><p>Linux中的流-与几乎所有其他内容一样-被视为文件。您可以从文件中读取文本，也可以将文本写入文件。这两个操作都涉及数据流。因此，将数据流作为文件处理的概念并不是很复杂。</p><p>与进程相关联的每个文件都分配了一个唯一的编号来标识它。这称为文件描述符。每当需要对文件执行操作时，都会使用文件描述符来标识该文件。</p><p>这些值始终用于stdin、stdout和stderr：</p><p>
0：标准输入。
1：标准输出。
2：标准错误</p><p>对管道和重定向做出反应</p><p>为了使某人更容易地了解某一主题，一种常见的技巧是讲授该主题的简化版本。例如，在语法中，我们被告知规则是“I在E之前，除了在C之后。”但实际上，这条规则的例外情况比遵守它的情况要多。</p><p>同样，在讨论stdin、stdout和stderr时，可以很方便地提出公认的公理，即进程既不知道也不关心它的三个标准流在哪里终止。进程是否应该关心它的输出是去往终端还是被重定向到文件中？它甚至能分辨出它的输入是来自键盘还是从另一个进程通过管道输入到它的吗？</p><p>实际上，进程确实知道-或者至少它可以发现，如果它选择检查-如果软件作者决定添加该功能，它可以相应地更改其行为。</p><p>我们可以很容易地看到这种行为的变化。尝试这两个命令：</p><code>ls</code><img class="content_img" src="/image/c7/c713eef27a0d584cb28769a734906194.png" /><code>ls | cat</code><img class="content_img" src="/image/ef/ef500c46afb2e984203c5a721ec67b01.png" /><p>如果ls命令的输出(Stdout)通过管道传输到另一个命令，则ls命令的行为会有所不同。切换到单列输出的是Cls，它不是由CAT执行的转换。如果它的输出被重定向，ls也会做同样的事情：</p><code>ls > capture.txt</code><img class="content_img" src="/image/5a/5a64f2691693d152e28ba873560c7fd8.png" /><code>cat capture.txt</code><img class="content_img" src="/image/5e/5e2aab6d1ce7822fb2ac176bcff6fc6b.png" /><p>重定向标准输出和标准错误</p><p>由专用流传递错误消息有一个优势。这意味着我们可以将命令的输出(Stdout)重定向到文件，并且仍然可以在终端窗口中看到任何错误消息(Stderr)。如果需要，您可以在错误发生时对其做出反应。它还可以防止错误消息污染标准输出重定向到的文件。</p><p>在编辑器中键入以下文本并将其保存到名为error.sh的文件中。</p><code>#!/bin/bash

echo "About to try to access a file that doesn't exist"
cat bad-filename.txt</code><p>使用以下命令使脚本可执行：</p><code>chmod +x error.sh</code><p>脚本的第一行通过stdout流将文本回显到终端窗口。第二行试图访问一个不存在的文件。这将生成通过stderr传递的错误消息。</p><p>使用以下命令运行脚本：</p><code>./error.sh</code><img class="content_img" src="/image/9b/9bd3bb6633b57d93bd7c8bb844fe202e.png" /><p>我们可以看到，输出流stdout和stderr都显示在终端窗口中。</p><img class="content_img" src="/image/48/48ed71250ee46fbba4268a46bef06463.png" /><p>让我们尝试将输出重定向到一个文件：</p><code>./error.sh > capture.txt</code><img class="content_img" src="/image/1a/1ab30370fce2a62b943c60388e0b8eef.png" /><p>通过STDERR传送的错误消息仍被发送到终端窗口。我们可以检查该文件的内容，以查看stdout命令输出是否发送到该文件。</p><code>cat capture.txt</code><img class="content_img" src="/image/24/2445a0c5d3d103b0b0f0b132764e489f.png" /><p>如预期的那样，stdin的输出被重定向到该文件。</p><img class="content_img" src="/image/e2/e225848cd1ef489a45de05882465e202.png" /><p>默认情况下，&gt;重定向符号适用于标准输出。您可以使用其中一个数字文件描述符来指示您希望重定向哪个标准输出流。</p><p>要显式重定向标准输出，请使用以下重定向指令：</p><code>1></code><p>要显式重定向stderr，请使用以下重定向指令：</p><code>2></code><p>让我们再试一次我们的测试，这次我们将使用2&gt;：</p><code>./error.sh 2> capture.txt</code><img class="content_img" src="/image/54/542e4f6ea48a70cbf164f19c014fe304.png" /><p>错误消息被重定向，并将标准输出回应消息发送到终端窗口：</p><img class="content_img" src="/image/a7/a7b6e4bc9e76ebd4b61f9ddc71d591af.png" /><p>让我们看看capture.txt文件中有什么。</p><code>cat capture.txt</code><img class="content_img" src="/image/24/2445a0c5d3d103b0b0f0b132764e489f.png" /><p>不出所料，stderr消息位于capture.txt中。</p><img class="content_img" src="/image/3f/3ffbffcc1dcc9679cbc9133325d5c4c1.png" /><p>重定向标准输出和标准错误</p><p>当然，如果我们可以将stdout或stderr重定向到彼此独立的文件，那么我们应该能够同时将它们重定向到两个不同的文件？</p><p>是的，我们可以。此命令将把stdout定向到一个名为capture.txt的文件，将stderr定向到一个名为error.txt的文件。</p><code>./error.sh 1> capture.txt 2> error.txt</code><img class="content_img" src="/image/c6/c61d0929a67ea0cbe4819a8931c0be7a.png" /><p>因为输出流(标准输出和标准错误)都被重定向到文件，所以终端窗口中没有可见的输出。我们返回到命令行提示符，就好像什么都没有发生一样。</p><img class="content_img" src="/image/51/5161edfd0813dc0c049b1e6efb2a3282.png" /><p>让我们检查一下每个文件的内容：</p><code>cat capture.txt</code><code>cat error.txt</code><img class="content_img" src="/image/d9/d9dc819ad70bf855a7f8f8b24d067595.png" /><p>将标准输出和标准错误重定向到同一文件</p><p>这很好，我们将每个标准输出流都放到了它自己的专用文件中。我们唯一可以做的另一种组合是将stdout和stderr发送到同一个文件。</p><p>我们可以使用以下命令来实现这一点：</p><code>./error.sh > capture.txt 2&>1</code><p>我们来分析一下。</p><p>
./error.sh：启动error.sh脚本文件。
&gt;capture.txt：将stdout流重定向到capture.txt文件。&gt;是1&gt;的简写。
2&gt;&1：这使用&&gt;重定向指令。此指令允许您告诉shell使一个流到达与另一个流相同的目的地。在本例中，我们说“将流2(Stderr)重定向到流1(Stdout)正被重定向到的同一目的地。”</p><img class="content_img" src="/image/19/19d4c5994dc63fcf5efcebdc5c585800.png" /><p>没有可见的输出。这很鼓舞人心。</p><img class="content_img" src="/image/42/42ebd0950af1451f5a749f3b9d900960.png" /><p>让我们检查capture.txt文件，看看里面有什么。</p><code>cat capture.txt</code><img class="content_img" src="/image/4b/4bfeb5a3af8fb24c48729180329d7d0a.png" /><p>stdout和stderr流都已重定向到单个目标文件。</p><p>要重定向并静默丢弃流的输出，请将输出定向到/dev/null。</p><p>检测脚本中的重定向</p><p>我们讨论了命令如何检测是否有任何流被重定向，并可以选择相应地改变其行为。我们可以用我们自己的脚本来实现这一点吗？是的，我们可以。而且这是一种非常容易理解和使用的技术。</p><p>在编辑器中键入以下文本，并将其另存为input.sh。</p><code>#!/bin/bash

if [ -t 0 ]; then

  echo stdin coming from keyboard
 
else

  echo stdin coming from a pipe or a file
 
fi</code><p>使用以下命令使其可执行：</p><code>chmod +x input.sh</code><p>最聪明的部分是方括号内的测试。如果与文件描述符相关联的文件在终端窗口中终止，则-t(终端)选项返回TRUE(0)。我们使用文件描述符0作为测试的参数，该参数表示DSTDIN。</p><p>如果标准输入连接到终端窗口，则测试将被证明为真。如果标准输入连接到文件或管道，则测试将失败。</p><p>我们可以使用任何方便的文本文件来生成脚本的输入。这里我们使用的是一个名为dummy.txt的文件。</p><code>./input.sh < dummy.txt</code><img class="content_img" src="/image/fe/fe6fb7aaf642f65250ff927b9a66c5e0.png" /><p>输出显示脚本识别出输入不是来自键盘，而是来自文件。如果您选择这样做，您可以相应地改变脚本的行为。</p><img class="content_img" src="/image/74/741f3117620032f4655c8c4c5351f939.png" /><p>这是通过文件重定向实现的，让我们使用管道进行尝试。</p><code>cat dummy.txt | ./input.sh</code><img class="content_img" src="/image/55/55254fb1146d9d409ff45ce6282d2b22.png" /><p>脚本识别出它的输入正在通过管道传输到它。或者更准确地说，它再次识别出标准输入流没有连接到终端窗口。</p><img class="content_img" src="/image/df/df8a84855b9dbd146381f1021b44e248.png" /><p>让我们既不使用管道也不使用重定向来运行脚本。</p><code>./input.sh</code><img class="content_img" src="/image/d0/d0f939508d6572483a53d77c71c06988.png" /><p>标准输入流连接到终端窗口，脚本相应地报告这一点。</p><p>要对输出流进行同样的检查，我们需要一个新脚本。在编辑器中键入以下内容并将其另存为output.sh。</p><code>#!/bin/bash

if [ -t 1 ]; then

echo stdout is going to the terminal window
 
else

echo stdout is being redirected or piped
 
fi</code><p>使用以下命令使其可执行：</p><code>chmod +x input.sh</code><p>此脚本唯一重要的更改是在方括号中的测试中。我们使用数字1表示标准输出的文件描述符。</p><p>让我们试试看吧。我们将通过CAT通过管道输出。</p><code>./output | cat</code><img class="content_img" src="/image/7c/7c3d24aa9f150ea5607265f5f5ca0a9e.png" /><p>该脚本识别其输出不会直接进入终端窗口。</p><img class="content_img" src="/image/dc/dcd4c2e08f1d0b6b0637082cd661e90b.png" /><p>我们还可以通过将输出重定向到文件来测试脚本。</p><code>./output.sh > capture.txt</code><img class="content_img" src="/image/83/834617ec179e31e078f8167c0d0083f4.png" /><p>终端窗口没有输出，我们被静默返回到命令提示符。正如我们所料。</p><img class="content_img" src="/image/f5/f58232220234afa1b4d7a3b1b3c92b7e.png" /><p>我们可以在capture.txt文件中查看捕获的内容。请使用以下命令执行此操作。</p><code>cat capture.sh</code><img class="content_img" src="/image/c6/c625cc1a5a9dd08e85adde34abd4306a.png" /><p>同样，我们脚本中的简单测试检测到标准输出流没有直接发送到终端窗口。</p><p>如果我们在没有任何管道或重定向的情况下运行脚本，它应该会检测到stdout正在直接传递到终端窗口。</p><code>./output.sh</code><img class="content_img" src="/image/0a/0af94f041ef7974351706998f1b506c9.png" /><p>这正是我们所看到的。</p><img class="content_img" src="/image/47/4746639704b6100c956afef07e14c9a8.png" /><p>意识流</p><p>了解如何判断您的脚本是否连接到终端窗口、管道或正在被重定向，这样您就可以相应地调整它们的行为。</p><p>日志记录和诊断输出可能更详细，也可能更少，具体取决于它是显示在屏幕上还是显示在文件中。错误消息可以记录到与正常程序输出不同的文件中。</p><p>和往常一样，更多的知识带来更多的选择。</p><div class="item_info"><span class="item_key"><a href="/tag/文件/">文件</a></span><span class="item_key"><a href="/tag/重定向/">重定向</a></span><span class="item_key"><a href="/tag/输出/">输出</a></span></div></div><div class="relate_story"><div><h3>相关文章</h3></div><ul><li><a href="/story/14797.html">如何在Linux上使用JOIN命令</a><li><a href="/story/14796.html">如何在Linux上使用JOIN命令</a><li><a href="/story/14627.html">解释的Linux文件时间戳：atime、mtime和ctime</a><li><a href="/story/14624.html">解释的Linux文件时间戳：atime、mtime和ctime</a><li><a href="/story/14550.html">如何在Linux上使用Tail命令</a><li><a href="/story/14514.html">您想知道的关于Linux上的inode的所有信息</a><li><a href="/story/14471.html">如何在Google Drive中更改文件所有者</a><li><a href="/story/14454.html">如何在Linux上使用stat命令</a><li><a href="/story/14347.html">如何使用cURL从Linux命令行下载文件</a><li><a href="/story/14306.html">如何创建USB驱动器的映像</a><li><a href="/story/14240.html">如何在Linux上使用LESS命令</a><li><a href="/story/14188.html">如何最终确定和撤销对共享Google文件的访问</a><li><a href="/story/14167.html">如何共享指向您的Google文件的“复制”链接</a><li><a href="/story/14164.html">如何将Google文档、工作表或幻灯片文件共享为网页</a><li><a href="/story/14127.html">如何在iPhone和iPad上将文件复制和备份到外部存储</a><li><a href="/story/14024.html">如何快速搜索Google Drive</a><li><a href="/story/13983.html">如何在Linux上使用chown命令</a><li><a href="/story/13968.html">如何将音乐复制到Android手机</a><li><a href="/story/13912.html">你能在Windows PC或Android手机上使用AirDrop吗？</a><li><a href="/story/13883.html">如何在PowerPoint演示文稿中使用iTunes音乐</a></ul></div></div><div id="footer">&copy 2020 fuzadu.com</div></body></html>