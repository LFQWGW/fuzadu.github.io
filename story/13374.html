<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何从Linux终端挂载和卸载存储设备</title><link rel="stylesheet" href="/css.css"><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?f75329719d379998b2421a4cc2396366";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="header"><a class="site_title" href="http://www.fuzadu.com">复杂度</a></div><div><div><h2>如何从Linux终端挂载和卸载存储设备</h2></div><div class="content"><p>Linux和类似Unix的操作系统(如MacOS)中的文件系统可以使用终端进行挂载、卸载和重新挂载。这是一个功能强大、用途广泛的工具-这里是您需要了解的所有内容。</p><p>Linux文件系统</p><p>Linux、MacOS和其他类Unix操作系统中的文件系统不像Windows那样对存储设备使用单独的卷标识符。Windows为每个卷分配一个驱动器号，如C：或D：，每个卷的文件系统是位于该驱动器号下方的目录树。</p><p>在Linux中，文件系统是一个多合一的目录树。挂载的存储设备将其文件系统嫁接到该树上，使得它看起来像是一个内聚文件系统的组成部分。新挂载的文件系统将可通过其挂载到的目录进行访问。该目录称为该文件系统的挂载点。</p><p>许多文件系统在引导时自动挂载，或在运行时作为连接到计算机的存储卷动态挂载。谨慎的系统管理员可以关闭运行时自动挂载功能，以便他们可以控制与系统的连接。</p><p>这意味着在运行时连接的存储设备可能不会自动装载，需要手动装载。通过手动挂载文件系统，您可以做出有关该文件系统的决策，例如挂载点将位于何处，以及文件系统是只读还是读写。</p><p>无论是出于必要还是通过选择，mount、umount和remount命令都使您能够控制Linux系统的这一重要方面。</p><p>使用装载询问您的文件系统</p><p>MOUNT有很多选项，但要列出计算机上所有已挂载的文件系统，根本不需要任何选项。只需键入mount并按Enter键即可：</p><img class="content_img" src="/image/f2/f2a68243854547a41075e3b52e086e85.png" /><p>装载将在终端窗口中列出所有连接的文件系统。</p><img class="content_img" src="/image/68/684f6524e67ed986807e5fac4ca4afb9.png" /><p>可能很难从数据转储中挑选出您要查找的内容。</p><p>您可以通过要求mount仅列出您感兴趣的文件系统来优化输出。t(Type)选项告诉装载要报告的文件系统类型。</p><code>mount -t tmpfs</code><code>mount -t ext4</code><img class="content_img" src="/image/ef/ef50c7116789ab34a1582b5f0ba4ebe1.png" /><p>例如，我们要求mount仅列出两个tmpfs文件系统。我们得到了更容易管理的产出。</p><p>tmpfs文件系统看起来像是一个常规的挂载文件系统，但它实际上存储在易失性存储器中(tmp代表临时)，而不是存储在永久存储设备上。</p><p>您需要用tmpfs参数替换您感兴趣的文件类型。</p><p>我们还发出了列出ext4文件系统的命令。在这台测试计算机上，只有一个ext4文件系统，它位于设备SDA上-第一个挂载的存储设备，通常是主硬盘驱动器-并挂载在/上，/是文件系统树的根。</p><p>其他指标表示：</p><p>
RW：文件系统是可读和可写的。
相对而言：内核使用优化方案记录文件访问和修改元数据。
error=remount-o：如果检测到足够严重的错误，将以只读模式重新挂载文件系统以进行诊断。</p><p>相关：您应该使用哪种Linux文件系统？</p><p>使用DF询问您的文件系统</p><p>df命令还可以用来显示哪些文件系统已挂载，以及它们的挂载点在哪里。</p><p>不带参数地使用df会给你带来和mount一样的信息过载问题。例如，在Ubuntu和Linux中，有一个squashfs伪文件系统是为使用snap命令安装的每个应用程序创建的。谁会想要看到所有这些文件系统呢？</p><p>要强制DF忽略它们(或任何其他文件系统类型)，请使用-x(排除)选项：</p><code>df -x squashfs</code><img class="content_img" src="/image/21/21f877e210dd4ef1ff6a637f037a662a.png" /><p>您可以很容易地看到文件系统的名称、它们的容量、已用空间和空闲空间以及它们的挂载点。</p><p>相关：如何从Linux终端查看可用磁盘空间和磁盘使用情况</p><p>重新装载fstab中的所有文件系统</p><p>所有在引导时挂载的文件系统在一个名为fstab的文件中都有条目，该文件是位于/etc内的文件系统表。</p><p>您可以使用mount强制“刷新”并重新挂载fstab中列出的所有文件系统。在正常运行条件下，这不是必需的。如果您遇到多个文件系统的问题，它就会真正发挥作用。</p><p>您需要使用sudo，因此系统将提示您输入密码。</p><code>sudo mount -a</code><img class="content_img" src="/image/8b/8b937449c9bc3d1dfd22a81fdfab3f27.png" /><p>诚然，在一台正常运行的计算机上，它有点平淡无奇。</p><p>但是，在出现文件系统问题的计算机上，重新挂载可能会解决这些问题。如果没有出现这种情况，那么至少您将在屏幕上和系统日志中获得诊断消息，这些消息将指导您查找问题的原因。</p><p>相关：什么是Linux fstab文件，它是如何工作的？</p><p>挂载ISO映像</p><p>挂载ISO映像很容易，这样您就可以将其内容作为文件系统的一部分进行访问。</p><p>这将适用于任何ISO映像。在这个例子中，我们碰巧使用的是一个很小的Core Linux-ISO，因为它很小，下载起来也很快。(一个带有GUI的小型Linux发行版，大小为18MB！您可能有更大的.mp3文件。)</p><p>在与ISO映像相同的目录中，发出此命令。替换您要挂载的ISO文件的名称。</p><code>sudo mount -t iso9660 -o loop TinyCore-current.iso /mnt</code><img class="content_img" src="/image/78/7814984fdb5efeffa4a95fdc7f558c24.png" /><p>因为我们需要使用sudo，所以您需要输入密码。</p><p>t(Type)选项告诉mount我们挂载的是哪种类型的文件系统。它是一个ISO文件，所以我们提供了iso9660类型说明符。</p><p>o(选项)标志用于传递额外的参数以挂载。我们的参数是循环。</p><p>我们使用循环强制mount使用循环设备文件连接到我们的ISO映像。循环设备文件允许将文件(如ISO映像)挂载并将其视为存储设备。</p><p>设备文件是用作接口的特殊文件，因此连接的设备看起来就像是普通的文件系统文件。这是Linux中一切都是文件设计理念的一部分。</p><p>有许多不同类型的设备文件。“我们在前面看到过一个，当时我们注意到这台测试机器上唯一的ext4文件系统挂载在/上，名为sda。</p><p>更准确地说，ext4文件系统位于通过/dev/sda文件连接到文件系统的存储设备上，而该存储设备上的文件系统挂载在/上。</p><p>当然，我们必须提供ISO映像的名称，并且需要让mount知道我们希望将文件系统挂载到哪里。我们已选择/mnt。</p><p>ISO映像已装载。终端窗口中会出现一条提示，提示ISO映像始终以只读模式挂载。</p><p>探索ISO映像</p><p>现在它已挂载，我们可以像浏览文件系统的任何其他部分一样导航ISO映像中的目录。“让我们列出ISO映像中的文件。它安装在/mnt，请记住。</p><code>ls /mnt</code><code>ls /mnt/cde/</code><img class="content_img" src="/image/e2/e20e81e4f1de37a231d310764c365159.png" /><p>卸载ISO映像</p><p>要卸载已装载的文件系统，请使用umount命令。注意，在“u”和“m”之间没有“n”-命令是umount，而不是“unmount”。</p><p>您必须告诉umount您要卸载的是哪个文件系统。为此，请提供文件系统的挂载点。</p><code>sudo umount /mnt</code><img class="content_img" src="/image/56/5622a9e99e7c67331f2ed9969081d4e8.png" /><p>不闻凶讯便是吉。如果没有什么要报告的，那么一切都很顺利。</p><p>创建装载点</p><p>您可以创建和使用您自己的装载点。我们将创建一个名为isomnt的文件，并将ISO映像挂载到该文件上。挂载点只是一个目录。因此，我们可以使用mkdir创建新的挂载点。</p><code>sudo mkdir /media/dave/isomnt</code><img class="content_img" src="/image/93/9338d33de81729637bb2dab24e398231.png" /><p>现在，我们可以使用与之前相同的命令格式来挂载ISO映像。这次我们不会将其挂载到/mnt上，而是将其挂载到/media/dave/isomnt/上：</p><code>sudo mount -r -t iso9660 -o loop TinyCore-current.iso /media/dave/isomnt/</code><img class="content_img" src="/image/cf/cf56365e0226e958d150468f6d01b819.png" /><p>现在，我们可以从新的挂载点访问挂载的文件系统。</p><code>ls /media/dave/isomnt/cde/optional</code><img class="content_img" src="/image/ec/ec1fa97b4a255c633127021233a3821c.png" /><p>但这些道路正变得非常漫长。这很快就会变得令人厌烦。让我们对此做点什么吧。</p><p>绑定装载点</p><p>您可以将挂载点绑定到另一个目录。然后，可以通过原始挂载点或绑定到它的目录访问已挂载的文件系统。</p><p>这里有一个很好的例子。我们将在主目录中创建一个名为iso的目录。然后，我们将ISO映像/media/dave/isomnt的挂载点绑定到主目录中的新iso目录。</p><p>我们将能够通过原始挂载点/media/dave/isomnt和新的iso目录访问ISO映像。-B(绑定)选项需要装载点的名称和要将其绑定到的目录的名称。</p><code>mkdir iso</code><code>sudo mount -B /media/dave/isomnt/ iso</code><code>ls iso</code><code>ls /media/dave/isomnt</code><code>cd iso</code><code>ls</code><code>cd cde</code><img class="content_img" src="/image/c1/c177fadae0d8e45c4e17e520fb2d3c7b.png" /><p>将umount与绑定一起使用</p><p>已将其挂载点绑定到另一个目录的文件系统需要从其挂载点和绑定点卸载。</p><p>即使我们从文件系统的原始挂载点卸载文件系统，您仍然可以从其绑定的目录访问文件系统。还必须从该目录卸载文件系统。</p><code>sudo umount /media/dave/isomnt</code><code>ls iso
</code><code>sudo umount iso</code><code>ls iso</code><img class="content_img" src="/image/d3/d3e4fb55d6f2ced62003dcdbe737b08e.png" /><p>挂载软盘</p><p>软盘驱动器(里面有一张软盘)是一种存储设备。这意味着将使用SD(存储设备)设备文件连接到物理设备。我们必须确定哪个是下一个免费的SD设备文件。我们可以通过以下方式实现这一点：通过grep管道传输df的输出，并查找其中包含“sd”的条目。</p><code>df | grep /dev/sd</code><img class="content_img" src="/image/23/23842c8b3d9ce3d2016f8d3800b4e8b1.png" /><p>在此计算机上，只有一个SD设备文件正在使用。这是/dev/sda。发出的下一个SD设备文件将是/dev/sdb。这意味着当我们将软盘驱动器连接到计算机时，Linux将使用/dev/sdb连接到软盘驱动器。</p><p>我们将告诉mount将连接到/dev/sdb的软盘驱动器中的软盘上的文件系统挂载到/mnt挂载点。</p><p>将软盘插入软驱，并将软驱连接到计算机上的USB端口。发出以下命令：</p><code>sudo mount /dev/sdb /mnt</code><img class="content_img" src="/image/11/1165f6075e7b92c7aef8e50ba52771de.png" /><p>文件系统标签</p><p>我们可以将-l(标签)选项与mount一起使用，以找出文件系统附加了什么标签(如果有的话)。标签只不过是任意的名称。它们没有功能用途。</p><p>我们使用-t(Type)选项要求装载只报告vFAT文件系统。</p><code>mount -l -t vfat</code><img class="content_img" src="/image/24/240a8dc1ac8a05e5e01cda5d27e9edde.png" /><p>您可以在清单末尾的方括号中找到标签。此软驱的标签是NORTUN。</p><p>我们可以通过/mnt挂载点访问软盘驱动器。</p><code>cd /mnt</code><code>ls</code><code>ls -l AMATCH.C</code><img class="content_img" src="/image/ba/ba43be38f6fac1e5a6f16c3f274697f5.png" /><p>该软盘包含C语言源代码文件。其中一个文件的日期戳显示它最后一次修改是在1992年10月。它可能比我们的很多读者都老。(不用说，NORTUN作为一个标签的意义已经消失在时间的迷雾中。)</p><p>如果我们重复通过grep命令输送的df命令来列出SD设备文件，我们将看到现在有两个这样的文件。</p><code>df | grep /dev/sd</code><img class="content_img" src="/image/fe/fe4e8215c56c68c608f8740332f72a1b.png" /><p>正如我们预期的那样，我们的软盘驱动器显示为已装载在/dev/sdb上。驱动器中软盘上的文件系统挂载在/mnt。</p><p>要卸载软盘，我们使用umount并将设备文件作为参数传递给它。</p><code>sudo umount /dev/sdb</code><img class="content_img" src="/image/47/47127f393cf1cfdbd16520cdbae2a753.png" /><p>umount Lazy选项</p><p>如果您(或其他用户)在尝试卸载文件系统时正在使用该文件系统，会发生什么情况？卸载将失败。</p><code>sudo umount /dev/sdb</code><img class="content_img" src="/image/2f/2ffffed74d6a547c66eeca6ff8800755.png" /><p>它失败了，因为用户的当前工作目录在他试图卸载的文件系统中。Linux足够聪明，不会让您看到您所坐的分支。</p><p>要克服此问题，请使用-l(惰性)选项。这会导致umount等待文件系统能够安全卸载。</p><code>sudo umount -l /dev/sdb</code><code>ls</code><code>cd ~</code><code>ls /mnt</code><img class="content_img" src="/image/d7/d7543fb638322d888ce00cd7ca518e65.png" /><p>即使发出了umount命令，文件系统仍处于挂载状态，用户可以照常列出文件。</p><p>一旦用户将目录切换到其主目录，软盘文件系统就会被释放并卸载。尝试列出/mnt中的文件不会产生任何结果。</p><p>装载Samba共享</p><p>Samba是一组软件服务，允许在Linux和类Unix操作系统以及Windows操作系统之间互换访问网络共享。</p><p>设置Samba超出了本文的范围。但是，如果您有权访问已向您提供的Samba共享，则可以通过以下方式将其挂载到Linux中。</p><p>连接到与测试机器相同的网络的Raspberry PI上有一个Samba共享。它是一个名为backup的目录，其Samba名称为“share”。让我们先与其建立SSH连接，然后查看共享目录的内容。共享目录位于安装在PI上的U盘上。</p><p>用户名是pi，Raspberry PI的网络名称是marnille.local。</p><code>ssh pi@marineville.local</code><code>ls /media/pi/USB64/Backup</code><code>exit</code><img class="content_img" src="/image/34/34bfad78851ac962775da7ed1a94a719.png" /><p>用户发出SSH命令并提示输入其Raspberry PI密码。</p><p>它们提供密码并经过身份验证。终端窗口提示更改为pi@mareville，因为它已连接到Raspberry PI。</p><p>它们在/media/pi/usb64/backup中列出共享目录的内容。内容是两个目录，一个名为dave，另一个名为pat。现在我们知道在挂载Samba共享时会发生什么。</p><p>他们键入exit以断开与Raspberry PI的连接，提示符会改回Dave@Howtogek。</p><p>要使用Samba，您必须安装cifs-utils软件包。</p><p>如果您使用的是Ubuntu或其他基于Debian的发行版，请使用apt-get将此软件包安装到您的系统上。在其他Linux发行版上，请改用您的Linux发行版的包管理工具。</p><code>sudo apt-get install cifs-utils</code><img class="content_img" src="/image/4c/4c92b58f90612286e8eee976c2c6551b.png" /><p>安装完成后，使用如下命令挂载共享，更改IP地址、共享名和挂载点(必须已存在)以适合您的环境。</p><code>sudo mount -t cifs -o credentials=/etc/samba/creds,uid=1000,gid=1000 //192.168.4.13/share /media/dave/NAS</code><img class="content_img" src="/image/d0/d039376666cb04505842f87fc36009af.png" /><p>让我们分解一下该命令的各个部分。</p><p>
-t cifs：文件系统类型为cifs。
-o Credentials=/etc/samba/creds，uid=1000，gid=1000：选项参数是名为creds的文件的路径，该文件受保护，包含Raspberry PI用户的用户名和密码；用于设置文件系统根目录的所有者和组的用户ID(UID)和组ID(GID)。
//192.168.4.13/share：包含Samba共享的设备的网络位置，以及共享目录的Samba名称。共享的根是一个名为backup的目录，但其Samba共享名设置为share。
/media/dave/NAS：挂载点的名称。您必须提前创建装载点。</p><p>通过访问位于/media/dave/nas的挂载点，我们可以跨网络访问Raspberry PI上的共享目录。我们可以在Raspberry PI上看到名为Dave和Pat的两个文件夹。</p><code>cd /media/dave/NAS</code><img class="content_img" src="/image/4f/4f80c1e2acc53527993464eeeeeb5f76.png" /><p>创建和装载文件系统</p><p>您可以使用dd命令创建一个映像文件，然后使用mkfs在其中创建一个文件系统。然后可以挂载该文件系统。这是练习和试验坐骑的好方法。</p><p>我们使用if(输入文件)选项告诉dd使用/dev/zer0中的零值流作为输入文件。</p><p>的(输出文件)是一个名为geek_fs的新文件。</p><p>我们使用BBS(块大小)选项来请求1MB的块大小。</p><p>我们使用COUNT选项告诉dd在输出文件中包含20个块。</p><code>dd if=/dev/zero of./geek_fs bs=1M count=20</code><img class="content_img" src="/image/cd/cd036a34b42afb2ae386bad344b4515d.png" /><p>它为我们创建了我们的图像文件。它只包含零值。</p><p>我们可以使用mkfs命令在geek_fs文件中创建工作文件系统。t(Type)选项允许我们选择文件系统类型。我们正在创建一个ext4系统。</p><code>mkfs -t ext4 ./geek_fs</code><img class="content_img" src="/image/7d/7d4d77e796beb1b455c8d285861108d3.png" /><p>这就是拥有一个正常工作的文件系统所需的全部条件。</p><p>让我们将其挂载到/media/dave/geek上，然后使用chown命令设置所有者和组所有权以允许访问它。</p><code>sudo mount ./geek_fs /media/dave/geek</code><code>sudo chown dave:users /media/dave/geek</code><img class="content_img" src="/image/3c/3cb7747bee4d108e731cf3ddd4a1fd31.png" /><p>它起作用了吗？让我们切换到新的文件系统，然后复制一个文件来查看。</p><code>cd /media/dave/geek</code><code>cp /etc/fstab .
</code><code>ls -l</code><img class="content_img" src="/image/50/5020c6343c15117fa16e3c9c547c9e65.png" /><p>我们能够将目录更改为新的文件系统，并且我们成功地复制了/etc/fstab文件。它起作用了！</p><p>如果我们使用mount列出已挂载的文件系统，但使用-t(Type)选项将其输出限制为ext4文件系统，我们将看到现在有两个已挂载的ext4文件系统。</p><code>mount -t ext4</code><img class="content_img" src="/image/4d/4d91e785f178ad3eea1e655e3d0b8558.png" /><p>重新装载文件系统</p><p>重新挂载文件系统时使用-o重新挂载选项。通常将文件系统从只读(测试)状态更改为读写(生产)状态。</p><p>让我们重新挂载我们的软盘驱动器。这次我们将使用-r(只读)标志。然后，我们将通过grep管道挂载并查看软盘文件系统的详细信息。</p><code>sudo mount -r /dev/sdb /mnt</code><code>mount | grep /mnt</code><img class="content_img" src="/image/45/459d883021e78f89f7b57c8e62aa6d6d.png" /><p>如您所见，突出显示的ro指示文件系统是以只读方式挂载的。</p><p>使用带有rw(读写)标志的-o remount选项，我们可以卸载并重新挂载具有新设置的文件系统，所有这些都在一个命令中完成。</p><code>sudo mount -o remount,rw /mnt</code><p>通过grep重复mount的管道，我们可以看到ro已经被rw替换(突出显示)。文件系统现在处于读写模式。</p><code>mount | grep /mnt</code><p>(非)移动文件系统</p><p>过去，您可以使用单个命令卸载文件系统并将其重新挂载到另一个挂载点。</p><p>挂载中的-M(移动)选项专门允许您这样做。但是它不再适用于已迁移到systemd的Linux发行版。这就是大多数大牌。</p><p>如果我们尝试将文件系统从/mnt移动到./geek，则会失败，并给出如下所示的错误消息。我试图通过./geek列出文件系统中的文件，但不返回任何结果。</p><code>sudo mount -M /mnt ./geek</code><code>ls ./geek</code><img class="content_img" src="/image/df/dfd9fd847f94c5eabac4fff575d92b3f.png" /><p>解决方法是使用我们之前使用的-B选项(绑定)将原始装载点绑定到新装载点。</p><code>sudo mount -B /mnt ./geek</code><code>ls ./geek</code><p>除了不会释放原来的挂载点外，这也会有同样的实际效果。</p><p>最终观测结果</p><p>使用--make-private选项可以强制在linux的systemd版本上进行迁移。这里没有介绍该技术，原因有两个。</p><p>
它可能有不可预知的行为。
它不是持久的，每次重新启动时都需要重复。</p><p>Devuan Linux使用的是SysV init，而不是systemd。一台电脑装载了最新版本的Devuan并进行了测试。-M(移动)选项在该系统上按预期工作。</p><p>除了-M挂载(移动)选项的systemd问题之外，您应该会发现mount和umount的用法非常简单。在面对损坏的系统时，这些命令非常有用，您必须开始手动将文件系统重新拼装起来。</p><div class="item_info"><span class="item_key"><a href="/tag/文件系统/">文件系统</a></span><span class="item_key"><a href="/tag/挂载/">挂载</a></span><span class="item_key"><a href="/tag/使用/">使用</a></span></div></div><div class="relate_story"><div><h3>相关文章</h3></div><ul><li><a href="/story/14199.html">如何在Linux上使用mkfs命令</a><li><a href="/story/13549.html">如何在Linux上将ext2或ext3文件系统迁移到ext4</a><li><a href="/story/13136.html">如何从Linux终端查看可用磁盘空间和磁盘使用情况</a><li><a href="/story/7311.html">什么是文件系统？为什么会有这么多文件系统？</a><li><a href="/story/6446.html">NTFS或FAT32：为内部SSD数据分区选择最佳文件系统</a><li><a href="/story/5079.html">文件系统只是一堆文件夹吗？(说明文件系统)</a><li><a href="/story/4375.html">为什么Linux不需要碎片整理</a><li><a href="/story/3285.html">我应该为我的USB驱动器使用什么文件系统？</a><li><a href="/story/2612.html">什么是Linux fstab文件，它是如何工作的？</a><li><a href="/story/2519.html">您应该使用哪个Linux文件系统？</a></ul></div></div><div id="footer">&copy 2020 fuzadu.com</div></body></html>