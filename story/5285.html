<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>极客学校：了解如何在PowerShell中使用作业</title><link rel="stylesheet" href="/css.css"></head><body><div id="header"><a class="site_title" href="http://www.fuzadu.com">复杂度</a></div><div><div><h2>极客学校：了解如何在PowerShell中使用作业</h2></div><div class="content"><img class="content_img" src="/image/20/207ea41ab315096bfcdb3ed62317373a.png" /><p>PowerShell有四种类型的作业-后台作业、远程作业、WMI作业和计划作业。欢迎加入我们的行列，了解它们是什么以及我们如何使用它们。</p><p>请务必阅读本系列的前几篇文章：</p><p>
了解如何使用PowerShell自动化Windows。
学习在PowerShell中使用Cmdlet。
了解如何在PowerShell中使用对象。
在PowerShell中学习格式化、筛选和比较。
学习在PowerShell中使用远程处理。
使用PowerShell获取计算机信息。
在PowerShell中使用集合</p><p>在接下来的一周里，我们将继续关注这一系列的节目。</p><p>后台作业</p><p>到目前为止，我在PowerShell中向您展示的所有内容都是同步的，这意味着我们在shell中键入一些内容，在该命令执行完毕之前，实际上不能做太多事情。这就是后台工作的用武之地。要启动后台，作业只需将脚本块传递给Start-Job cmdlet。</p><img class="content_img" src="/image/85/85a0288688c9a2feda853df12ca58f2e.png" /><p>现在，当该脚本块在后台执行时，我们可以在shell中随意执行任何操作。</p><img class="content_img" src="/image/f7/f74f173ea5e9fd87f110e0d492f7dfd0.png" /><p>启动新作业时，PowerShell会创建一个表示该作业的新作业对象。您可以通过运行Get-Job cmdlet随时获取所有作业的列表。</p><img class="content_img" src="/image/56/565ae5ff83f4e3979ccf2d6262fd1ae1.png" /><p>作业对象告诉您作业的状态。例如，在上面的屏幕截图中我们可以看到，我们有一个名为GetFileList的Background Job，它仍在运行，但已经开始返回数据。如果您在任何时候确定作业已经运行了太长时间，您可以通过管道将其发送到Stop-Job来轻松地停止它。</p><img class="content_img" src="/image/82/82b429dc07fdde3efd489621e6173338.png" /><p>但是，一旦您停止了作业，在您停止该作业之前它接收到的任何数据都仍然可用。不过，还是有个问题。在PowerShell中，一旦您收到作业的结果，它们就会被删除。为了保留它们，您必须指定Receive-Job的Keep开关参数。</p><img class="content_img" src="/image/b5/b5571c8bd698501d75be1bf9548fd391.png" /><p>完成作业后，最佳做法是删除该作业。要删除作业，只需通过管道将其传递给Remove-Job cmdlet。</p><p>这会将其从Get-Job返回的作业列表中删除。</p><img class="content_img" src="/image/a0/a0502f38849f675fbd0ac100ec39d36a.png" /><p>远程作业</p><p>几节课之前，我们了解了如何使用Invoke-Command使用远程处理在远程计算机上执行PowerShell命令，但是您知道您也可以使用Invoke-Command在后台启动远程处理作业吗？要执行此操作，只需将-AsJob参数添加到命令的末尾：</p><img class="content_img" src="/image/30/30ca11ace8dbf1e5ae9f455c73724d44.png" /><p>这是一个简单的命令，现在应该已经执行完毕，所以让我们来看看我们的作业状态。</p><img class="content_img" src="/image/a4/a4e5ef9f0ca6e78cd57b49145a98a847.png" /><p>嗯，看起来失败了。这让我想到了我在工作方面的第一个难题。在PowerShell中创建任何类型的新作业时，除了为您运行作业的每台计算机创建一个子作业外，还会创建一个父作业。使用Get-Job cmdlet时，它仅显示父作业，状态属性是最坏情况方案，这意味着即使命令仅在一百台计算机中的一台上运行失败，父作业状态也会显示为失败。要查看子作业列表，需要使用IncludeChildJob参数。</p><img class="content_img" src="/image/8b/8b39ce7847562277b842f85cb4f35186.png" /><p>如果仔细观察，您会发现该作业确实只在一台计算机上失败，这将我们带到下一个问题。当您尝试获取作业的结果时，如果指定父作业的名称或ID，PowerShell将返回所有子作业的数据。问题是，如果某个子作业中有错误，我们会留下一些红色文本。</p><img class="content_img" src="/image/3d/3df6230f602efb82251db6a005288bcd.png" /><p>有两种方法可以绕过这个问题。首先，如果您知道要为哪些计算机获取结果，只需使用Receieve-Job cmdlet的ComputerName参数即可。</p><img class="content_img" src="/image/93/93d074774f5aca27d5b376df61e28747.png" /><p>或者，您可以使用特定子作业的作业ID获取结果。</p><img class="content_img" src="/image/03/03fe46eacbe98b9622e94562b055e87f.png" /><img class="content_img" src="/image/64/64b9be1f4f00c9a045dca54f4f41e5a5.png" /><p>WMI作业</p><p>WMI作业与远程作业基本相同，只需要将-AsJob参数添加到Get-WmiObject cmdlet。</p><img class="content_img" src="/image/43/43c035e45acb604b14d61f5a42c1b297.png" /><img class="content_img" src="/image/92/92506e559bb3ddbe95f9e5b22f91b848.png" /><p>不幸的是，这意味着它们也会受到我在远程作业一节中提到的相同问题的影响。</p><p>计划的作业</p><p>我们查看的最后三种作业不是永久性的，这意味着它们仅在您的当前会话中可用。基本上，这意味着如果您启动一个作业，然后打开另一个PowerShell控制台并运行Get-Job，您将不会看到任何作业。但是，返回到启动作业的控制台，您将能够看到其状态。这与持久的计划作业不同。基本上，计划作业是按计划运行的脚本块。在过去，使用Windows Task Scheduler可以达到同样的效果，这实际上就是在幕后发生的事情。要创建新的计划作业，请执行以下操作：</p><p>这个命令中有相当多的内容，所以让我们把它分解一下。</p><p>
首先，我们将计划作业的名称命名为GetEventLogs。
然后我们告诉它，当被触发时，我们希望它运行指定脚本块的内容，这基本上会获得安全事件日志的最新100个条目。
接下来，我们指定一个触发器。由于Trigger参数接受触发器对象作为输入，因此我们使用了一个括号命令来生成触发器，该触发器将在每天下午5点触发。
由于我们正在处理事件日志，因此需要以管理员身份运行，我们可以通过创建新的ScheduledJobOption对象并将其传递给ScheduledJobOption参数来指定管理员身份。</p><img class="content_img" src="/image/21/21d80321fa81376024a39f48a5e18691.png" /><p>由于这是一种略有不同的作业类型，因此您还需要使用不同的命令来检索计算机上所有计划作业的列表。</p><img class="content_img" src="/image/52/52b6bd217530056bb3fa7f24c65f81f7.png" /><p>非那样做不行。</p><div class="item_info"><span class="item_key"><a href="/tag/作业/">作业</a></span><span class="item_key"><a href="/tag/使用/">使用</a></span><span class="item_key"><a href="/tag/powershell/">powershell</a></span></div></div><div class="relate_story"><div><h3>相关文章</h3></div><ul><li><a href="/story/4209.html">如何在Linux终端中执行多任务：同时使用多个shell的3种方法</a></ul></div></div><div id="footer">&copy 2020 fuzadu.com</div></body></html>