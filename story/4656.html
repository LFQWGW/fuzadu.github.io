<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>CPU和GPU如何交互以渲染计算机图形？</title><link rel="stylesheet" href="/css.css"></head><body><div id="header"><a class="site_title" href="http://www.fuzadu.com">复杂度</a></div><div><div><h2>CPU和GPU如何交互以渲染计算机图形？</h2></div><div class="content"><img class="content_img" src="/image/04/04f522fe7af7f6f46300b0847ecfcb60.jpg" /><p>照片由Sskennel提供。</p><p>今天的问答环节是由超级用户提供的，这是Stack Exchange的一个分支，Stack Exchange是一个社区驱动的问答网站群。</p><p>问题</p><p>超级用户读者Sathya提出了这个问题：</p><p>在这里，您可以看到一个名为Triangle.exe的C++小程序的屏幕截图，其中包含一个基于OpenGL API的旋转三角形。</p><img class="content_img" src="/image/3a/3afcda005fe7b588ead4d3aff20327d5.jpg" /><p>诚然，这是一个非常基本的例子，但我认为它也适用于其他显卡操作。</p><p>我只是好奇，想知道从双击Windows XP下的Triangle.exe直到我在显示器上看到三角形旋转的整个过程。发生了什么，CPU(首先处理.exe)和GPU(最终在屏幕上输出三角形)如何交互？</p><p>我猜显示这个旋转三角形主要涉及以下硬件/软件等：</p><p>硬设备 / 硬件 / 五金器具 / 计算机硬件</p><p>
硬盘。
系统内存(RAM)。
中央处理器。
视频内存。
GPU。
液晶显示器</p><p>软件</p><p>
操作系统。
DirectX/OpenGL API。
NVIDIA驱动程序</p><p>有没有人能解释一下这个过程，也许可以用流程图来说明一下？</p><p>它不应该是涵盖每一个步骤的复杂解释(我猜这会超出范围)，而是一个中级IT人员可以遵循的解释。</p><p>我敢肯定，很多自称IT专业人士的人都不能正确地描述这个过程。</p><p>答案</p><img class="content_img" src="/image/84/846a0a56b10f0d7dec5a02316fd7a30c.jpg" /><p>尽管有多名社区成员回答了这个问题，但奥利弗·萨尔茨伯格(Oliver Salzburg)走得更远，他不仅回答了详细的问题，还附上了出色的附图。</p><p>图片由JasonC提供，壁纸形式请点击此处。</p><p>他写道：</p><p>我决定写一点关于编程方面以及组件如何相互通信的内容。也许它会给某些地区带来一些启示。</p><p>演示文稿</p><p>怎样才能把你在问题中发布的那张图片画在屏幕上呢？</p><p>在屏幕上画三角形有很多种方法。为简单起见，我们假设没有使用顶点缓冲区。(顶点缓冲区是存储坐标的内存区域。)。让我们假设程序简单地告诉图形处理流水线关于一行中的每个单个顶点(顶点只是空间中的一个坐标)的信息。</p><p>但是，在我们可以画任何东西之前，我们首先必须运行一些脚手架。我们稍后再看原因：</p><p>那这是怎么回事呢？</p><p>当您编写想要使用图形卡的程序时，您通常会选择某种类型的驱动程序接口。驱动程序的一些众所周知的接口包括：</p><p>
OpenGL。
Direct3D。
库达</p><p>对于本例，我们将继续使用OpenGL。现在，您与驱动程序的接口为您提供了使您的程序与图形卡(或驱动程序，然后驱动程序与卡通信)对话所需的所有工具。</p><p>此界面一定会为您提供某些工具。这些工具采用API的形式，您可以从程序中调用它。</p><p>该API就是我们在上面的示例中看到的。让我们仔细看看。</p><p>脚手架</p><p>在您可以真正进行任何实际绘制之前，您必须执行设置。您必须定义您的视口(将实际渲染的区域)，您的视角(进入您的世界的相机)，您将使用什么抗锯齿(以平滑三角形的边缘)…</p><p>但我们不会看任何这些。我们只需看一看你每一帧都要做的事情。比如：</p><p>清除屏幕</p><p>图形管道不会为您清除每一帧的屏幕。你得说出来。为什么？这就是为什么：</p><img class="content_img" src="/image/3d/3dc21ecb8d10cf28e2f4de142c3c45e9.jpg" /><p>如果您不清除屏幕，您将简单地在每一帧上绘制它。这就是我们在设置了GL_COLOR_BUFFER_BIT的情况下调用glClear的原因。另一位(GL_DEPTH_BUFFER_BIT)告诉OpenGL清除深度缓冲区。此缓冲区用于确定哪些像素在其他像素的前面(或后面)。</p><p>彻底的改变 / 转换 / 改革 / 变形</p><img class="content_img" src="/image/d7/d7e4f9fc9ed763b98d94775891323366.jpg" /><p>转换是我们获取所有输入坐标(三角形的顶点)并应用ModelView矩阵的部分。这是解释我们的模型(顶点)如何旋转、缩放和平移(移动)的矩阵。</p><p>接下来，我们应用我们的投影矩阵。这会移动所有坐标，以便它们正确面对我们的相机。</p><p>现在，我们使用视口矩阵再次变换。我们这样做是为了将模型缩放到监视器的大小。现在我们有一组可以渲染的顶点了！</p><p>我们稍后再回来讨论转型问题。</p><p>图画 / 图表 / 构图 / 牵引</p><p>要绘制一个三角形，我们可以简单地告诉OpenGL通过使用GL_TRIALES常量调用glBegin来开始一个新的三角形列表。
你还可以画其他的表格。就像三角形条带或三角形扇子。这些主要是优化，因为它们需要较少的CPU和GPU之间的通信来绘制相同数量的三角形。</p><p>之后，我们可以提供一个由3个顶点组成的列表，这些顶点应该组成每个三角形。每个三角形使用3个坐标(就像我们在3D空间中一样)。此外，我还通过在调用glVertex3f之前调用glColor3f为每个顶点提供了颜色。</p><p>3个顶点(三角形的3个角)之间的阴影由OpenGL自动计算。它将在多边形的整个面上插值颜色。</p><p>相互作用 / 相互影响 / &lt;物理&gt;交互作用</p><p>现在，当你点击窗口时。应用程序只需捕获发出点击信号的窗口消息。然后，您可以在程序中运行任何您想要的操作。</p><p>一旦您想要开始与3D场景交互，这将变得更加困难。</p><p>您首先必须清楚地知道用户在哪个像素单击了窗口。然后，考虑到您的视角，您可以从鼠标单击进入场景的位置计算光线的方向。然后可以计算场景中是否有任何对象与该光线相交。现在您知道用户是否单击了对象。</p><p>那么，你怎么让它旋转呢？</p><p>彻底的改变 / 转换 / 改革 / 变形</p><p>我知道通常应用的两种类型的转换：</p><p>
基于矩阵的变换。
基于骨骼的变换</p><p>不同之处在于骨骼影响单个顶点。矩阵始终以相同的方式影响所有绘制的顶点。让我们看一个例子。</p><p>例证 / 范例 / 榜样 / 例子</p><p>早些时候，我们在绘制三角形之前加载了单位矩阵。单位矩阵是一个简单地不提供任何变换的矩阵。所以，无论我画什么，都只受我的视角影响。所以，三角形根本不会旋转。</p><p>如果我现在想旋转它，我可以自己计算(在CPU上)，然后用其他坐标(旋转后)简单地调用glVertex3f。或者，我可以让GPU完成所有工作，方法是在绘制之前调用glRotatef.</p><code>// Rotate The Triangle On The Y axis glRotatef(amount,0.0f,1.0f,0.0f); </code><p>当然，数量只是一个固定值。如果你想要动画，你必须跟踪数量并增加它每一帧。</p><p>在这个简单的例子中，我们不必关心矩阵。我们只需调用glRotatef，它就会为我们处理所有这些问题。</p><p>嗯，谢谢你这么说！</p><p>结束 / 结尾 / 结论 / 推论</p><p>显而易见的是，有很多关于OpenGL的讨论。但它什么都没告诉我们。通讯在哪里？</p><p>在这个例子中，OpenGL告诉我们的唯一一件事就是它什么时候完成。每次手术都需要一定的时间。有些手术耗时长得令人难以置信，有些则快得令人难以置信。</p><p>将顶点发送到GPU将是如此之快，我甚至不知道如何表达它。将数千个顶点从CPU发送到GPU，每一帧，很可能根本没有问题。</p><p>清除屏幕可能需要一毫秒或更糟的时间(请记住，您通常只有大约16毫秒的时间来绘制每帧)，具体取决于您的视口有多大。要清除它，OpenGL必须以您想要清除的颜色绘制每个单独的像素，这可能是数百万像素。</p><p>除此之外，我们几乎只能向opengl询问我们图形适配器的功能(最大分辨率、最大抗锯齿、最大颜色深度、…)。。</p><p>但是我们也可以用像素填充纹理，每个像素都有特定的颜色。因此，每个像素都有一个值，纹理是一个充满数据的巨大“文件”。我们可以将其加载到图形卡中(通过创建纹理缓冲区)，然后加载着色器，告诉该着色器使用我们的纹理作为输入，并在我们的“文件”上运行一些极其繁重的计算。</p><p>然后，我们可以将计算结果(以新颜色的形式)“渲染”到新纹理中。</p><p>这就是如何让GPU在其他方面为您工作。我认为CUDA的性能与此类似，但我从未有机会使用它。</p><p>我们真的只略微触及了整个主题。3D图形编程是一头地狱般的野兽。</p><img class="content_img" src="/image/28/28c97e972c81ce78a14b191de91dc891.jpg" /><p>对解释有什么补充吗？在评论中发声。想阅读其他精通技术的Stack Exchange用户的更多答案吗？点击这里查看完整的讨论主题。</p><div class="item_info"><span class="item_key"><a href="/tag/顶点/">顶点</a></span><span class="item_key"><a href="/tag/使用/">使用</a></span><span class="item_key"><a href="/tag/三角形/">三角形</a></span></div></div></div><div id="footer">&copy 2020 fuzadu.com</div></body></html>