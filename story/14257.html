<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何在Linux上编写fstab文件</title><link rel="stylesheet" href="/css.css"></head><body><div id="header"><a class="site_title" href="http://www.fuzadu.com">复杂度</a></div><div><div><h2>如何在Linux上编写fstab文件</h2></div><div class="content"><p>是否向您的Linux计算机添加新的硬盘或固态硬盘？您需要编辑fstab文件。很多人觉得这个想法很可怕。是的，你做对了很重要，但有了正确的知识，这真的不难。我们将引导您完成编辑fstab文件的过程，以便将新驱动器集成到您的文件系统中。</p><p>fstab，文件系统表</p><p>虽然向Linux计算机添加新硬盘并不太复杂，但第一次尝试时可能会有点困惑。您可以连接硬件，打开计算机电源，然后登录到操作系统。但是你在任何地方都看不到你的新硬盘。为什么它没有出现呢？如何让Linux“看到”驱动器，以便您可以开始配置它？</p><p>实际上，Linux已经看到了您的硬件，但它不会轻易宣布这一点。或者甚至给你一个提示，它已经找到了你的新硬件。您必须询问Linux以获得需要放入fstab文件中的信息。</p><p>下面介绍如何设置您的新硬盘，以便Linux-以及您-可以看到并使用它。这个过程分为两个部分。第一部分是进行一些侦察，以识别硬盘并收集有关它的一些信息。第二部分是使用我们在侦察阶段收集的信息编辑fstab文件。</p><p>查找您的新硬盘</p><p>我们正在向这个系统添加两个新的驱动器。一个是32 GB的机械硬盘(HD)，另一个是16 GB的固态硬盘(SSD)。</p><p>我们需要知道Linux是否可以看到它们，以及Linux正在为它们使用哪些块设备。在Linux和类似Unix的操作系统中，块设备是一个特殊的文件，它充当设备的接口，可以读取和写入数据(除非它是只读的)。块设备通常代表某种类型的大容量存储单元(例如，硬盘或CD-ROM上的分区)。它们在/dev目录中创建。</p><p>我们可以使用lsblk命令列出连接到您的Linux计算机的块设备。</p><code>lsblk</code><img class="content_img" src="/image/44/44238d0445a9e6236951032bad28e3fe.png" /><p>lsblk的输出按列显示。</p><img class="content_img" src="/image/c9/c9957f6a0f2f98ff544d0087e03c9c2e.png" /><p>这些列包括：</p><p>
名称：这是设备名称。以“SD”开头并后跟字母的设备名称表示SCSI硬盘。字母标识各个硬盘，“a”是第一个，“b”是第一个。成为第二个，以此类推。如果附加了数字，则表示分区。例如，“sdb2”将是第二个SCSI硬盘驱动器上的分区2。
MAJ：MIN：此列保存设备的主要编号和次要编号。主编号指示设备的类型(或者，更准确地说，是用于与该设备通信的驱动程序的类型)。次要编号是该类型的设备数量的计数。
RM：此栏显示设备是否可拆卸。请注意，设备sr0的值为1，表示它是可移除的。这是一个CD-ROM驱动器。
大小：这是设备中可以存储的数据量。
RO：此列将为只读设备显示1，为读写设备显示0。环路设备都是只读的。
类型：这标识设备的类型。“磁盘”条目表示磁盘驱动器，“部分”条目表示分区，而“ROM”表示只读存储器(CD-ROM)。
挂载点：这显示文件系统中挂载此设备的位置。如果此字段为空，则不会装载设备。</p><p>在上面的屏幕截图中，您可以看到，所有循环设备的主编号都是7(意味着环回或环回设备)，而次要编号每次都简单地递增1。循环设备与squashfs文件系统一起使用。每次使用Snappy包管理系统安装应用程序时，都会创建一个squashfs文件系统。</p><p>SCSI硬盘的名称包括SDA、SDB和SDC，并且所有硬盘的主编号都是8(SCSI硬盘)。次要编号按16分组。第一个驱动器SDA的次要编号从0到15。0表示实体驱动器，次要编号1表示该驱动器上的第一个分区。对于第二个驱动器SDB，次要编号从16到31。16表示实体驱动器，17表示该驱动器上的第一个分区。接下来的16个数字(32到47)用于SDC的次要号码，依此类推。</p><p>其他常见的主要数字是3(用于IDE硬盘)和11(用于CD-ROM)。</p><p>实际上，SDCSI CD-ROM驱动器的/dev/sr0样式已弃用。批准的格式为/dev/scd0。尽管如此，在研究本文的所有机器上仍在使用/dev/sr0格式。</p><p>内核文档包含一个很长的列表，其中列出了主号和次号可以取的所有值。这是一份令人惊讶的长名单。</p><p>要整理lsblk的输出，我们可以使用grep只选择我们感兴趣的项目。我们知道我们没有添加环路设备，所以让我们选择所有SCSI硬盘驱动器。我们知道它们的名字中会有“SD”。</p><code>lsblk | grep sd</code><img class="content_img" src="/image/35/35393ad593dda5a0cb8ef57f655fa28b.png" /><p>此命令将导致grep仅打印在中带有“sd”的行。在我们的测试计算机上，我们看到：</p><img class="content_img" src="/image/78/784351ed13863df6d894404ed169da95.png" /><p>因此，我们有三个SCSI驱动器。第一个文件/dev/sda挂载在文件系统的根目录/。另外两个根本没有挂载，这在全新的驱动器中是可以预料到的。我们可以看到驱动器/dev/sdb的大小为32 GB，这意味着它是我们传统的机械驱动器。驱动器/dev/sdc大小为16 GB，这是我们的固态硬盘驱动器。</p><p>实际上，由于这是一台虚拟计算机，所以这些也是虚拟磁盘。因此，固态硬盘就像SCSI机械驱动器一样出现。在我的常规桌面上，我的NVMe SSD文件显示为/dev/nvme0n1，其中的第一个分区是/dev/nvme0n1p1。它的主要号码是259。这些差异不会改变我们必须在fstab文件中执行的操作，但请注意，如果您有SSD，它不会显示为实体驱动器。</p><p>此外，如果您的驱动器是全新的，那么它们上可能不会有分区。如果需要，您可以使用fdisk创建分区。</p><p>相关：如何在Linux上使用Fdisk管理分区</p><p>识别旋转和非旋转驱动器</p><p>如果我们将-o(输出)选项与lsblk一起使用，并将rota列(旋转)添加到显示中，则lsblk将使用1表示旋转存储设备(机械驱动器)，使用0表示非旋转存储设备(固态驱动器)。</p><code>lsblk -o +ROTA | grep sd</code><img class="content_img" src="/image/af/af90a88571f368b7dcb785e659c7c206.png" /><p>我们在显示屏的右侧有一个额外的列，它是ROTA(旋转)列。如您所见，“SSD”的设备和分区为0。这是有意义的，因为SSD是非旋转存储设备。</p><img class="content_img" src="/image/73/7375a33add41cce31d003f09105886ce.png" /><p>装载文件系统</p><p>在我们开始考虑fstab文件之前，让我们检查一下是否可以手动挂载驱动器。这样，如果我们使用fstab文件时有些东西不工作，我们就知道问题一定是我们的语法问题，而不是驱动器本身的问题。</p><p>我们将在/mnt目录中创建一些临时挂载点。您需要使用sudo，系统将提示您输入密码。</p><code>sudo mkdir /mnt/scsi</code><img class="content_img" src="/image/79/79db3fa80b16534c672fcc6c94348b91.png" /><code>sudo mkdir /mnt/ssd</code><img class="content_img" src="/image/c7/c7da62af52b86c682a88d35b9715925a.png" /><p>现在，让我们将SCSI驱动器挂载到新的挂载点。我们将使用最简单形式的mount命令。我们将告诉它我们想要挂载的分区的名称，以及我们想要挂载它的挂载点。MOUNT将在指定的挂载点将文件系统挂载到该分区上。</p><p>我们指定的是保存文件系统的分区，而不是驱动器，因此请确保包含分区的数字，在本例中为“1”。</p><code>sudo mount /dev/sdb1 /mnt/scsi</code><img class="content_img" src="/image/cd/cdb784ff1b8c59bc4bed9348113c1e47.png" /><p>如果一切顺利，坐骑就不会有任何回应。您将静默返回到命令提示符。</p><p>安装固态硬盘同样简单。我们告诉mount要在哪个设备上挂载哪个分区，以及要挂载它的挂载点。</p><code>sudo mount /dev/sdc1 /mnt/ssd</code><img class="content_img" src="/image/f7/f7bf59ebd8c3be8315529499f24b9888.png" /><p>再说一次，沉默是金。</p><p>相关：如何从Linux终端挂载和卸载存储设备</p><p>检查座架</p><p>要验证是否已进行挂载，我们将再次使用lsblk。我们将通过grep传递其输出，并选择“sda1”、“sdb2”和“sdc1”条目。</p><code>lsblk -o +ROTA | grep sd[a-c]1</code><img class="content_img" src="/image/ea/eaeb228333f623fbb2f48efe8842f54b.png" /><p>MOUNT向我们显示了三个挂载的分区。这是我们刚刚挂载的两个分区，原始分区挂载在/上。</p><img class="content_img" src="/image/13/138e2a315c1871e3845531636877501d.png" /><p>分区/dev/sdb1挂载在/mnt/scsi上，并且位于旋转存储设备上。分区/dev/sdc1挂载在/mnt/ssd上，并且位于非旋转存储设备上。看起来一切都很好。</p><p>现在，我们需要配置fstab文件，以便在每次启动计算机时挂载这些设备。</p><p>fstab文件</p><p>fstab文件包含重新启动计算机时装载的每个文件系统的条目。每个条目由六个字段组成。这些字段是：</p><p>
文件系统：顾名思义，不是分区上的文件系统类型(这就是type字段的作用)。这是应该装载的分区的标识符。
挂载点：文件系统中希望挂载分区的位置。
类型：分区上的文件系统类型。
选项：每个文件系统都可以指定打开或关闭功能的选项。
转储：引用一种几乎过时的文件系统备份方法，将整个文件系统“转储”到磁带上。
通过：这是“通过”的旗帜。它告诉Linux应该使用fsck检查哪些分区是否有错误，以及检查的顺序。您的主引导和操作系统分区应该是1，其余的可以设置为2。如果该标志设置为0，则表示“根本不检查”。如果您的文件系统不是日志文件系统(例如，ext2或FAT16/32)，最好通过将其设置为0来关闭它。</p><p>这些字段必须按此顺序指定，并且它们之间必须有空格或制表符。查找这些字段的值可能会令人望而生畏，尤其是“选项”字段的值。“Options”字段选项必须在逗号分隔的列表中，中间不能有空格。</p><p>每个文件系统的手册页将列出可以使用的选项。ext4大约有40个选项，以下是一些比较常见的选项：</p><p>
自动：文件系统将在引导时自动挂载。
noauto：仅当您输入mount-a命令时才挂载文件系统。
EXEC：此文件系统上允许执行二进制文件。
Noexec：此文件系统上不允许执行二进制文件。
RO：文件系统应以只读方式挂载。
RW：文件系统应该以读写方式挂载。
同步：文件写入应该立即进行，而不是缓冲。最好留给软盘，如果有人还在使用的话。会招致性能损失。
异步：应缓冲和优化文件写入。
用户：任何用户都可以挂载文件系统。
Nouser：root用户是唯一可以挂载此文件系统的用户。
默认值：这是指定一组常用设置的快捷方式：rw、suid、dev、exec、auto、nouser和async)。
SUID：允许操作SUID和SGID位。suid位用于允许普通用户以超级用户身份执行文件，而无需给予用户完全的超级用户权限。在目录上设置SGID位时，在该目录中创建的文件和目录的组所有权将设置为该目录的组所有权，而不是设置为创建它们的用户组的组所有权。
nosuid：不允许使用suid和sgid位。
Noatime：-不要更新文件系统上的文件访问时间。这有助于提高旧硬件的性能。
Nodiatime：不要更新文件系统上的目录访问时间。
Relatime：相对于文件修改时间更新文件访问时间。</p><p>“默认”选项是一个很好的开场白。如果需要进行一些微调，您可以添加或删除更多选项。如果有一种巧妙的方法来获得您需要的设置，请按照您需要将它们输入到fstab文件中的顺序进行设置。</p><p>输入mtab文件。</p><p>mtab文件</p><p>mtab文件是当前挂载的文件系统的列表。这与fstab文件不同，fstab文件列出了应该在引导时挂载的文件系统。mtab文件包括手动挂载的文件系统。我们已经挂载了新驱动器，因此它们应该会显示在mtab文件中。</p><p>我们可以使用cat查看mtab文件的内容。我们将通过grep来限制输出，只查看/dev/sdb1和/dev/sdc1。</p><code>cat /etc/mtab | grep sd[b-c]1</code><img class="content_img" src="/image/ff/ffe9af4986093d322d0c12bdf218e957.png" /><p>输出显示了这两个分区的mtab条目。</p><img class="content_img" src="/image/df/dffd17e93f2ef7ca7d4bbd58dec93ed3.png" /><p>我们可以提升这些值并将它们直接放到fstab文件中，确保每个字段之间有一个空格或制表符。就是这样。驱动器将在我们重新启动时挂载。</p><p>对此有两个警告。一个是挂载点。我们创建临时挂载点只是为了证明我们可以在新驱动器上挂载新分区。我们需要输入真正的装载点，而不是我们的临时装载点-如果它们不同的话。</p><p>第二个警告是，如果我们使用mtab文件中的设置，我们将使用块设备文件作为每个分区的标识符。这是可行的，但是如果向计算机添加新的大容量存储硬件，则/dev/sda和/dev/sdb等值有更改的风险。这将意味着Ffstab文件中的设置将是不正确的。</p><p>每个分区都有一个通用唯一标识符(UUID)，我们可以使用它来标识分区。这一点永远不会改变。如果我们使用UUID来标识fstab文件中的分区，则设置将始终保持准确。</p><p>如果将新分区用作廉价磁盘冗余阵列(RAID)系统的一部分，请查阅该系统的文档。它可能指定您必须使用数据块设备标识符，而不是UUID。</p><p>查找分区的UUID</p><p>要查找分区的UUID，可以使用blKID*打印块设备的属性。我们将把输出限制到新驱动器上的两个新分区：</p><code>blkid | grep sd[b-c]1</code><img class="content_img" src="/image/d9/d9bc23c907e70ff19f91fdd6abbdf824.png" /><p>输出包括每个分区的UUID。</p><img class="content_img" src="/image/51/51e087d42dcad577541f75b72c25f549.png" /><p>PARTUUID是UUID的一种形式，可以与GUID分区表(GPT)分区方法一起使用(如果您没有使用主引导记录(MBR)分区方法)。</p><p>编辑fstab文件</p><p>在编辑器中打开fstab文件。我们使用的是Gedit，这是一个在大多数Linux发行版中都可以找到的易于使用的编辑器。</p><code>sudo gedit /etc/fstab</code><img class="content_img" src="/image/bc/bcb76a5115456aab21fc4f7edcb606f5.png" /><p>此时将出现编辑器，其中加载了您的fstab文件。</p><img class="content_img" src="/image/ff/ff4a9eb5b4344d9e3307ed7adc46b8ed.png" /><p>此fstab文件中已有两个条目。它们是现有硬盘驱动器/dev/sda1上的分区和交换文件系统。注意不要更改这些条目。</p><p>我们需要向fstab文件添加两个新条目。一个用于SCSI驱动器上的分区，另一个用于SSD驱动器上的分区。我们将首先添加SCSI分区。请注意，以hash#开头的行是注释。</p><p>
在“file system”字段中，我们将使用blid早先为我们检索到的UUID。以“uuid=”开始行，然后粘贴uuid。按空格键或Tab键。
对于“mount point”字段，我们将使用前面创建的挂载点：/mnt/scsi。您将使用系统中的适当挂载点。按空格键或Tab键。
对于“type”，我们将输入ext4，这是我们分区上的文件系统类型。按空格键或Tab键。
在“Options”字段中，我们将使用使用cat/etc/mtab检索到的选项。这些是“RW，Relatime”。按空格键或Tab键。
“转储”字段设置为零。按空格键或Tab键。
将“PASS”字段设置为零。</p><p>现在，我们将在SSD驱动器上的单独行上添加fstab条目分区。</p><p>
在“file system”字段中，我们将输入BLID为SSD驱动器上的分区检索到的UUID。以“uuid=”开始行，然后粘贴uuid。按空格键或Tab键。
对于“mount point”字段，我们将使用之前创建的挂载点：/mnt/ssd。按空格键或Tab键。
对于“type”，我们将输入ext4，这是我们分区上的文件系统类型。按空格键或Tab键。
在“Options”字段中-只是为了使我们示例中的两个新条目不同-我们将使用“Defaults”选项。按空格键或Tab键。
“转储”字段设置为零。按空格键或Tab键。
将“PASS”字段设置为零。</p><img class="content_img" src="/image/46/460221cd6fc5111ae3131dc391063e60.png" /><p>保存文件并关闭编辑器。</p><p>相关：如何使用Gedit在Linux上以图形方式编辑文本文件</p><p>在不重新启动的情况下测试fstab</p><p>我们可以卸载新驱动器，然后强制刷新fstab文件。成功挂载新分区将验证我们输入的设置和参数在语法上是否正确。这意味着我们的fstab文件在重新启动或通电序列期间应该得到正确处理。</p><p>要卸载SCSI驱动器，请使用此命令。请注意，“umount”中只有一个“n”：</p><code>sudo umount /dev/sdb1</code><img class="content_img" src="/image/d1/d187021c6c57a90c3b17cbdd9a0dfe0d.png" /><p>要卸载SSD驱动器，请使用以下命令：</p><code>sudo umount /dev/sdc1</code><img class="content_img" src="/image/5a/5a0fca1b0e96f10128f09340db8f410b.png" /><p>现在，我们将使用lsblk检查这些块设备是否已挂载。</p><code>lsblk | grep sd</code><img class="content_img" src="/image/90/90b08c9e1eb8146eb8b885b41c857c2d.png" /><p>我们看到，块设备存在于计算机中，但没有安装在任何地方。</p><img class="content_img" src="/image/e6/e6a1e39859dae2217253abc4ed697bcf.png" /><p>我们可以使用mount命令和-a(All)选项重新挂载fstab中的所有文件系统。</p><code>sudo mount -a</code><img class="content_img" src="/image/09/09d314ce2317bb473b395a3ffca557c9.png" /><p>我们可以再次使用lsblk进行检查，以查看我们的新分区现在是否已挂载：</p><code>lsblk | grep sd</code><img class="content_img" src="/image/72/725f7e6482abaf24784d0772e9e1f11c.png" /><p>所有东西都挂载在它应该在的地方。我们现在要做的就是更改挂载点的所有权，否则root将是唯一可以访问新存储设备的人。</p><p>使用Chown可以很容易地做到这一点。以下是用于SCSI装入点的命令：</p><code>sudo chown dave:users /mnt/scsi</code><img class="content_img" src="/image/e1/e10092950abc0adafe7dd02009ea0b15.png" /><p>以下是用于SSD装载点的命令：</p><code>sudo chown dave:users /mnt/ssd</code><img class="content_img" src="/image/86/860919cda766df3eec67e08c637376a1.png" /><p>我们现在可以放心地重新启动计算机，因为我们知道已经添加的分区将为我们挂载，并且我们可以访问它们。</p><p>毕竟没那么可怕</p><p>所有艰苦的工作都在侦察阶段--这也不难。一旦收集到所需的信息，编辑fstab文件就轻而易举了。准备就是一切。</p><div class="item_info"><span class="item_key"><a href="/tag/使用/">使用</a></span><span class="item_key"><a href="/tag/分区/">分区</a></span><span class="item_key"><a href="/tag/文件系统/">文件系统</a></span></div></div><div class="relate_story"><div><h3>相关文章</h3></div><ul><li><a href="/story/14706.html">如何在Linux上使用uniq命令</a><li><a href="/story/14624.html">解释的Linux文件时间戳：atime、mtime和ctime</a><li><a href="/story/14585.html">如何在Microsoft Excel中兑换货币</a><li><a href="/story/14577.html">如何检查Linux上安装了哪个GPU</a><li><a href="/story/14572.html">如何使用Jouralctl读取Linux系统日志</a><li><a href="/story/14570.html">如何在Linux上使用grep命令</a><li><a href="/story/14555.html">2020年CES最佳：我们今年看到的所有最好的东西</a><li><a href="/story/14550.html">如何在Linux上使用Tail命令</a><li><a href="/story/14542.html">如何从MacOS Catalina向iPhone添加自定义铃声</a><li><a href="/story/14508.html">如何使用键盘快捷键简化流媒体Netflix</a><li><a href="/story/14507.html">如何在Linux上使用HISTORY命令</a><li><a href="/story/14499.html">如何在Linux上使用免费命令</a><li><a href="/story/14467.html">如何在Windows 10上切换到本地用户帐户</a><li><a href="/story/14466.html">如何在Linux上使用at和Batch来调度命令</a><li><a href="/story/14461.html">如何设置您的新Mac</a><li><a href="/story/14450.html">如何在Excel中将一长列变为多列</a><li><a href="/story/14438.html">如何在iPhone上创建和使用Memoji和Animoji</a><li><a href="/story/14434.html">Chrome 79的新特性，现已推出</a><li><a href="/story/14426.html">如何使用Google Sheets中的查询功能</a><li><a href="/story/14424.html">如何向Outlook会议请求添加默认签名</a></ul></div></div><div id="footer">&copy 2020 fuzadu.com</div></body></html>