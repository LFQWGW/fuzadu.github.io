<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Linux中如何在向目录添加新文件时执行任务</title><link rel="stylesheet" href="/css.css"></head><body><div id="header"><a class="site_title" href="http://www.fuzadu.com">复杂度</a></div><div><div><h2>在Linux中如何在向目录添加新文件时执行任务</h2></div><div class="content"><p>本教程将向您展示如何使用Linux文件系统事件(Notify)在每次文件出现在目录中时收到通知。您可以将这些用作触发器，以自动执行系统上的常见任务。</p><p>我们将编写一个脚本来监视目录并处理添加的新文件。一旦检测到每个文件，就会立即对其进行gzip压缩并将其移动到另一个目录。该脚本通过名为inotify-tools的实用程序使用inotify子系统。但首先，让我们安装工具并进行实验。</p><p>安装inotify-tools和gzip</p><p>如果您使用的是Ubuntu或其他基于Debian的发行版，请使用apt-get将此软件包安装到您的系统上。在其他Linux发行版上，请改用您的Linux发行版的包管理工具。</p><code>sudo apt-get install inotify-tools gzip</code><p>尝试使用inotify工具</p><p>让我们从观察一个目录开始，看看当新文件到达时会启动哪些事件。我们将使用一个名为inotifywatch的工具，它是inotify-tools的一部分。创建一个名为“Income”的新目录：</p><code>mkdir incoming</code><p>通过执行以下命令开始监视此目录：</p><code>inotifywatch -v incoming</code><p>这将指示inotify监视“传入”目录中的所有文件系统事件。v选项使工具打印出有关其正在执行的操作的额外信息。我们没有指定超时选项(-t)，该命令将一直收集事件，直到我们使用CTRL+C退出。此时，我们的终端应该如下所示：</p><img class="content_img" src="/image/d9/d95799cb17dfb112343c1389ed9eddbd.png" /><p>打开新的终端窗口(或选项卡)并切换到传入目录。使用touch命令创建名为“newfile”的新文件。</p><code>cd incoming/
touch newfile
</code><p>现在返回到第一个终端窗口，按CTRL+C停止inotifywatch。</p><img class="content_img" src="/image/36/3649d01f800a0efd4fe2195d8771799c.png" /><p>将向控制台提供一个事件表，指示“create”、“open”、“attrib”和“CLOSE_WRITE”的一个实例。这四个事件发生在我们使用Touch创建一个新文件、设置其文件访问属性、打开它以写入空的终止字符，然后关闭它的时候。这些只是可以使用inotify工具在文件系统上监视的众多事件中的一小部分。你可以在inotifywatch的主页上看到完整的名单。</p><p>出于我们的目的，我们只对两个事件感兴趣：</p><p>
“创建”-在目标目录中创建文件时。
“Moved_To”-当文件从另一个位置移动到目标目录时。</p><p>让我们再次尝试inotifywatch，但这一次指示它只监视这两个事件。在第一个终端窗口中运行此命令：</p><code>inotifywatch -v -e create -e moved_to incoming</code><p>在第二个终端窗口或选项卡中，让我们尝试创建一个新文件，更改其内容，然后将该文件从另一个位置移动到目标目录。所有这些命令都是从主目录运行的。</p><code>touch incoming/created
echo Testing123 >> incoming/created
touch /tmp/created2
mv /tmp/created2 incoming/
</code><p>返回到第一个终端窗口，按CTRL+C停止inotifywatch。我们将看到以下输出：</p><img class="content_img" src="/image/12/122f26ec4f609b14c7969fd7bc079abf.png" /><p>只统计了两个事件：创建名为“created.txt”的文件和移动名为“created2.txt”的现有文件。其他所有内容都被忽略，比如修改“created.txt”。</p><p>监视目录和执行任务</p><p>现在我们知道了接下来会发生什么事件，我们可以使用另一个名为ninotifyWait的工具来阻止执行，直到在目标目录中创建文件或将其移动到目标目录为止。我们将使用与inotifywatch相同的参数，并指定如何格式化文件名以便在任务中使用。</p><p>在开始之前，我们需要一个目录来保存已经处理过的文件。创建名为“已处理”的目录：</p><code>mkdir processed</code><p>接下来，创建一个名为“watch-incoming.sh”的新脚本，并添加下面列出的内容：</p><code>#!/bin/bash

TARGET=~/incoming/
PROCESSED=~/processed/

inotifywait -m -e create -e moved_to --format "%f" $TARGET \
        | while read FILENAME
                do
                        echo Detected $FILENAME, moving and zipping
                        mv "$TARGET/$FILENAME" "$PROCESSED/$FILENAME"
                        gzip "$PROCESSED/$FILENAME"
                done
</code><p>该脚本通过带有-m选项的TinotifyWait命令执行。这会使命令监视器无限期更改。每次检测到新事件时，都会将文件名传递给读取命令并注入到“filename”变量中。执行WHILE循环下的块，在该块中，首先将文件移动到“已处理”目录，然后对其进行gzip压缩。原始文件将替换为压缩文件，文件名将以“.gz”结尾。</p><p>让我们授予对此脚本的EXECUTE权限，并从我们的主目录运行它。</p><code>chmod u+x watch-incoming.sh
./watch-incoming.sh</code><p>打开第二个终端窗口，并在“传入”目录中创建一个新文件。列出“传入”和“已处理”目录的内容，以查看检测到的事件的结果：</p><img class="content_img" src="/image/3c/3c5260e17e64e62c68b982df9b826e3e.png" /><p>脚本检测到我们复制到“传入”目录的原始文本文件，将其复制到“已处理”目录，然后使用gzip进行压缩。</p><p>现在我们可以执行一些有趣的任务，因为我们能够监视到达目录的新文件。例如，我们可以为图像文件添加水印，将原始视频压缩为MP4格式，甚至将我们看到的每个新文件都上传到Amazon S3存储桶中。此脚本是在系统上滚动您自己的工作流和自动执行常见任务的良好起点。</p><div class="item_info"><span class="item_key"><a href="/tag/文件/">文件</a></span><span class="item_key"><a href="/tag/使用/">使用</a></span><span class="item_key"><a href="/tag/事件/">事件</a></span></div></div><div class="relate_story"><div><h3>相关文章</h3></div><ul><li><a href="/story/14796.html">如何在Linux上使用JOIN命令</a><li><a href="/story/14712.html">如何使用Google Drive Progative Web App</a><li><a href="/story/14624.html">解释的Linux文件时间戳：atime、mtime和ctime</a><li><a href="/story/14550.html">如何在Linux上使用Tail命令</a><li><a href="/story/14514.html">您想知道的关于Linux上的inode的所有信息</a><li><a href="/story/14471.html">如何在Google Drive中更改文件所有者</a><li><a href="/story/14454.html">如何在Linux上使用stat命令</a><li><a href="/story/14419.html">如何在Linux中获取文件或目录的大小</a><li><a href="/story/14347.html">如何使用cURL从Linux命令行下载文件</a><li><a href="/story/14315.html">免费下载：Microsoft批量重命名PowerToy</a><li><a href="/story/14306.html">如何创建USB驱动器的映像</a><li><a href="/story/14240.html">如何在Linux上使用LESS命令</a><li><a href="/story/14209.html">如何在Google Drive中分配任务</a><li><a href="/story/14188.html">如何最终确定和撤销对共享Google文件的访问</a><li><a href="/story/14167.html">如何共享指向您的Google文件的“复制”链接</a><li><a href="/story/14164.html">如何将Google文档、工作表或幻灯片文件共享为网页</a><li><a href="/story/14127.html">如何在iPhone和iPad上将文件复制和备份到外部存储</a><li><a href="/story/14088.html">如何在iPhone或iPad上使用Safari下载文件</a><li><a href="/story/14037.html">如何在Linux上创建别名和Shell函数</a><li><a href="/story/14026.html">如何在Linux上使用chgrp命令</a></ul></div></div><div id="footer">&copy 2020 fuzadu.com</div></body></html>