<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何在Linux上创建别名和Shell函数</title><link rel="stylesheet" href="/css.css"></head><body><div id="header"><a class="site_title" href="http://www.fuzadu.com">复杂度</a></div><div><div><h2>如何在Linux上创建别名和Shell函数</h2></div><div class="content"><p>使用别名和Bash shell函数创建您自己的Linux命令。驯服重复性任务，截断冗长的过程，并使用您经常使用且难以记住的选项配置标准命令。</p><p>别名和shell脚本是Linux和类Unix操作系统中的强大技术，允许您磨练您的命令行体验以满足您的需要。您可以定义适合您特定需要的自己的命令，以减轻重复性任务的负担。</p><p>别名和shell脚本执行相同的工作。它们允许您定义和命名一组Bash shell功能，然后可以根据您为其指定的名称进行调用。与每次要使用所有步骤或命令相比，键入名称更容易、更方便。</p><p>别名和脚本之间的区别在于复杂性和规模。脚本更善于保存更长、更精细的代码块。别名非常适合保存更短、更简洁的命令集。</p><p>预定义别名</p><p>某些别名是为您预定义的。要查看系统中定义的别名列表，请使用不带参数的alias命令：</p><code>alias</code><img class="content_img" src="/image/a6/a64bf91eef468550085a41625f798b78.png" /><p>这些是本文研究的Ubuntu测试机上定义的别名。如果我定义了任何自定义别名，这些也会出现在这个列表中。</p><p>在列表的顶部，有一个看起来很复杂的别名，名为alert。我们稍后会谈到这一点。ls命令有一组不同的别名，还有一组别名为grep命令系列提供颜色输出。例如，定义了这些别名后，无论何时键入：</p><code>grep</code><p>系统会将其解释为：</p><code>grep --color=auto</code><p>这显示了别名的一个重要问题。它们可以与现有命令同名，甚至可以在其内部包含原始命令。</p><p>下面是grep别名的定义。</p><code>alias grep='grep --color=auto'</code><p>
ALIAS命令用于定义别名。
接下来给出别名的名称。在本例中，它是grep。
等号将别名的名称连接到别名的正文。对于除非常简单的别名之外的所有别名，别名的主体都用单引号括起来。
别名的主体是在命令行上使用别名时执行的部分。</p><p>该别名的主体只调用带有--color=auto选项的*grep命令。</p><p>警报别名</p><p>顺便说一句，为了让您知道它的作用，警报别名用于让您知道命令何时完成。它还指示命令是否成功完成。它在屏幕顶部提供图形系统警报。</p><p>这里有一个简单的例子。睡眠命令将休眠5秒钟，然后将调用警报别名。别名检查来自上一个命令的响应。它从历史文件中提取最后一个命令。它确定命令是否成功完成。然后，它会在系统警报中显示结果。</p><p>如果命令按预期完成，则系统警报中的图标是一个小终端窗口。如果命令返回错误代码，则系统警报中的图标为红色错误图标。</p><code>sleep 5; alert</code><img class="content_img" src="/image/07/0768408bd148584fab4beedf84377162.png" /><p>五秒钟后，我们会看到此系统警报：</p><img class="content_img" src="/image/9d/9db835c1d6f6019d170364dc66a7209a.png" /><p>该图标是一个小的终端窗口，意味着一切都进行得很顺利。让我们用一个我们知道会失败的命令再试一次：</p><code>DoomedToFail; alert</code><img class="content_img" src="/image/31/31593cb8f075efffbe683f2198204402.png" /><p>我们的系统警报现在有一个错误图标。</p><img class="content_img" src="/image/38/38536c945122aeb33e910ab038addd79.png" /><p>定义微不足道的别名</p><p>正如我们已经看到的，要定义别名，我们使用alias命令。</p><p>我们将为CLEAR命令创建一个假名。我们的别名将称为cls，它将调用Clear命令。</p><p>我们的别名定义非常琐碎，不需要用单引号括起来。如果别名的主体比这个复杂，或者如果它包含空格，请用单引号将其引起来。我们将定义别名，使用ls将一些输出放入终端窗口，然后使用我们的新别名cls清除屏幕。</p><code>alias cls=clear</code><code>ls -l</code><code>cls</code><img class="content_img" src="/image/2e/2ea996e7d46c2a1a21dd9cb39d5f7359.png" /><p>屏幕被清除了。成功了，尽管是短暂的。只有在此终端窗口保持打开状态时，别名才会继续存在。一旦窗口关闭，别名就会消失。</p><p>那么我们如何让我们的别名永久化呢？</p><p>.bashrc文件和别名</p><p>您可能想知道预打包的别名是在哪里定义的。它位于主文件夹的“.bashrc”文件中。每当启动交互式shell时，都会读取该文件，并执行其中的命令。也就是说，当您打开终端窗口时。</p><p>在您的主文件夹中键入以下命令，查看语法突出显示的“.bashrc”文件的内容。</p><code>gedit .bashrc</code><img class="content_img" src="/image/67/67da6b683c73741b3427057db908a30c.png" /><p>这将启动Gedit编辑器，其中加载了“.bashrc”文件。</p><img class="content_img" src="/image/89/8955159366b2bb9aeb9e91241c76ce97.png" /><p>高亮显示的区域显示了定义别名的两个区域。</p><p>滚动文档将显示与别名相关的另外两个部分：</p><img class="content_img" src="/image/92/9246fc2d31257f39a4e9cb43cdbe2671.png" /><p>第一个是警报别名的定义。第二个是if语句。它转换为“如果文件”.bash_aliases“存在，请将其读入。”</p><p>如果您只想定义几个别名，可以将它们放入“.bashrc”文件中。将它们塞到包含ls别名的部分下面。</p><p>如果您要创建许多别名，或者您只是喜欢将别名封装在它们自己的文件中，您可以在“.bash_aliases”文件中定义它们。在“.bash_aliases”文件中创建它们的一个好处是，您不会意外更改“.bashrc”文件中的任何设置。另一个优点是您的别名很容易复制到新系统，因为它们与“.bashrc”文件完全分离。</p><p>在.bash_aliases文件中存储别名</p><p>“.bash_aliases”文件只有在您创建后才会存在。*您可以使用以下命令创建该文件：</p><code>touch .bash_aliases</code><img class="content_img" src="/image/9e/9e951f532cc36d013e421a228999c6c2.png" /><p>让我们编辑该文件并为其添加几个别名。此命令将在Gedit编辑器中打开“.bash_aliases”文件。</p><code>gedit .bash_aliases</code><img class="content_img" src="/image/83/8318952623ad671e7ae43d94e14714e8.png" /><p>我们增加了三个别名。第一个是我们之前使用的CLS别名。下一个称为h，是调用历史命令的一种快捷方式。</p><p>第三个别名称为FTC。这代表“文件类型计数”。</p><p>这个别名比较复杂，所以用单引号括起来。它使用通过管道链接在一起的一系列命令。它生成不同文件扩展名和目录名的排序列表，每个列表条目都有计数。</p><p>相关：如何在Linux上使用管道</p><p>当我们保存了“.bash_aliases”文件时，我们可能希望我们的别名是活动的并且可以访问。事实并非如此。在别名定义生效之前，文件必须由Bash shell读入。每当打开交互式外壳时，都会执行此操作。</p><p>我们还可以使用内置的Bash shell。读取并执行文件中的命令。因为我们的“.bash_alias”文件是在处理“.bashrc”时读入的，所以我们应该通过调用“.bashrc”来执行测试。这样，我们就可以检查“.bash_alias”文件是否从“.bashrc”调用，以及我们的别名是否处于活动状态。</p><p>我们使用的命令包括：</p><code>gedit .bash_alias</code><p>编辑“.bash_alias”文件。</p><code>. .bashrc</code><p>这将读入并执行“.bashrc”中的命令，该命令将调用“.bash_alias”。</p><code>ftc</code><p>这将调用FTC别名。</p><img class="content_img" src="/image/8f/8f03e043693aecd736d125121cddd257.png" /><p>我们的别名会响应，这意味着Bash已经读取了“.bashrc”和“.bash_aliases”，我们的新别名现在可以使用了。</p><p>现在，您可以继续向“.bash_aliases”文件添加新别名。如果你发现自己做了一两次以上的事情，可以考虑给它取个别名。</p><p>删除别名</p><p>有一个命令可以删除别名，这样Bash就不会识别它们，也不会响应它们。令人耳目一新的直截了当的命令被称为unalias。</p><p>要使用它，请给出您希望让Bash忘记的别名的名称。要让Bash忘记我们的FTC别名，请按如下方式使用unalias：</p><code>unalias ftc</code><p>您可以使用unalias删除已定义的别名和任何预定义的别名。</p><p>要从系统中删除所有别名，请使用-a(All)选项：</p><code>unalias -a</code><p>不过，巴什的记忆力丧失不会是永久性的。下次打开终端窗口时，“被遗忘”的别名将会回来。要真正清除它们，您需要从“.bashrc”和“.bash_alias”文件中删除它们。</p><p>如果您想要回它们，不要从您的“.bashrc”文件中删除它们。相反，可以通过在每个别名行的开头添加散列#将其注释掉。要使“.bash_alias”文件无效，请将其重命名。如果您的“.bashrc”文件看不到它，它就不会读取它。逆转这些步骤以恢复您的别名是一件微不足道的事情。</p><p>外壳函数</p><p>Lika别名、Bash shell函数可以在“.bashrc”文件中定义，但通常将它们放在自己的定义文件中会更整洁。按照“.bash_aliases”文件使用的约定，我们将其命名为“.bash_Functions”。</p><p>这意味着我们需要告诉“.bashrc”文件读取我们的定义。我们可以复制和修改读取“.bash_aliases”文件的代码片段。启动Gedit并使用以下命令加载“.bashrc”文件：</p><code>gedit .bashrc</code><img class="content_img" src="/image/71/719a455953815852a4087d45fc176211.png" /><p>您需要添加如下所示的突出显示部分。</p><p>您可以高亮显示别名部分并按Ctrl+C，然后移动到想要创建新部分的位置，然后按Ctrl+V粘贴文本的副本。然后，您需要做的就是将显示为“.bash_aliases”的两个位置更改为“.bash_Functions”。</p><img class="content_img" src="/image/44/44b7f12e07030853f1170b2a6fb2fa18.png" /><p>我们可以保存这些更改并关闭Gedit。</p><p>现在，我们将创建并编辑“.bash_Functions”文件，并将函数定义放入其中。</p><code>touch .bash_functions</code><code>gedit .bash_functions</code><img class="content_img" src="/image/e7/e71469a06264539148ff934297eb177a.png" /><p>这将在Gedit中打开空的“.bash_function”文件。</p><p>我们将添加一个名为up的简单函数。UP将接受单个命令行参数，该参数是一个数字。UP然后将呼叫CD..。这个次数。因此，如果您使用命令</p><code>up 2</code><p>UP会呼叫CD..。两次，并且将在目录树中向上移动两级。</p><p>定义函数有不同的方式。这里有一个：</p><code>function up() {</code><p>单词功能是可选的。如果你是个传统主义者，那就用它，如果你懒得输入，就省略吧。</p><p>以下是我们在Gedit中的整个函数：</p><img class="content_img" src="/image/59/591b9b14b53cd9e6f3bc7fdcc1f5cf6a.png" /><code>function up() {</code><p>这标志着函数定义的开始，它将函数命名为up。</p><code>levels=$1</code><p>这将创建一个名为LELES的变量，并将其设置为第一个参数的值。此参数将是用户调用函数时提供的数字。$1表示“第一个命令行参数”。</p><code>while [ "$levels" -gt "0" ]; do</code><p>然后我们进入一个循环。这可以翻译为“当级别的值大于零时，执行循环体中包含的操作。”</p><p>在循环体内部，我们有两个命令。它们是：</p><code>cd ..</code><p>在目录树中上移一级。</p><code>levels=$(($levels - 1))</code><p>将级别设置为一个新值，该值比其当前值小一。</p><p>然后我们返回到循环的顶部，再次比较Level和0之间的值。如果级别大于零，则再次执行循环体。如果不大于零，则循环结束，我们跳转到Done语句，函数结束。</p><p>保存这些更改并关闭Gedit。</p><p>我们将读入并执行“.bashrc”中的命令，该命令应读入并执行“.bash_Functions”文件中的命令。</p><code>. .bashrc</code><img class="content_img" src="/image/07/0758c0ba1929ff22ee68a76a02a7b9ae.png" /><p>我们可以通过移动到目录树中的某个位置并使用Up移回目录树中的“更高”点来测试该功能。</p><code>cd ./work/backup/</code><code>up 2</code><img class="content_img" src="/image/68/68948f96e509f46f8efeea53a76b8473.png" /><p>该函数起作用。我们在树中将目录级别上移了两级。</p><p>跟踪类型</p><p>当您构建一套别名和函数库时，可能很难记住特定命令是别名还是函数。您可以使用type命令来提醒您。这里最酷的是，您还可以看到定义。</p><p>让我们对FTC别名和up函数使用type。</p><code>type ftc</code><code>type up</code><img class="content_img" src="/image/be/be767f1dde8ee27b95663a8a6bc04e42.png" /><p>我们得到一个非常有用的提示，告诉我们每个命令是什么类型，以及它们的定义。</p><p>开始收集</p><p>别名和函数可以极大地加快命令行的使用速度。它们可以缩短命令序列，并允许您烘焙始终与标准命令一起使用的选项。</p><p>每次看到漂亮的一行程序或有用的函数时，都可以对其进行调整和个性化，然后将其添加到“.bash_aliases”或“.bash_function”文件中。</p><div class="item_info"><span class="item_key"><a href="/tag/命令/">命令</a></span><span class="item_key"><a href="/tag/文件/">文件</a></span><span class="item_key"><a href="/tag/使用/">使用</a></span></div></div><div class="relate_story"><div><h3>相关文章</h3></div><ul><li><a href="/story/14507.html">如何在Linux上使用HISTORY命令</a><li><a href="/story/14466.html">如何在Linux上使用at和Batch来调度命令</a><li><a href="/story/14448.html">如何在Linux上使用Which命令</a><li><a href="/story/14302.html">如何在Linux上使用Echo命令</a><li><a href="/story/14121.html">如何在Linux上使用chroot命令</a><li><a href="/story/14091.html">如何在Linux上运行和控制后台进程</a><li><a href="/story/14013.html">Bash你需要知道的15个特殊字符</a><li><a href="/story/14001.html">如何在Linux上使用管道</a><li><a href="/story/13823.html">如何在Linux上使用xargs命令</a><li><a href="/story/13779.html">如何在Linux上使用rev命令</a><li><a href="/story/13739.html">如何监控Linux命令的进度(使用pv和Progress)</a><li><a href="/story/13621.html">如何从Linux终端列出您的计算机设备</a><li><a href="/story/13610.html">如何使用Linux type命令</a><li><a href="/story/13585.html">如何使用Linux的所有搜索命令</a><li><a href="/story/13474.html">如何在Linux上使用重命名命令</a><li><a href="/story/13312.html">如何从Linux终端杀死进程</a><li><a href="/story/13258.html">37个您应该知道的重要Linux命令</a><li><a href="/story/13253.html">如何使用命令行重新启动或关闭Linux</a><li><a href="/story/13218.html">如何在Linux上使用“Install”命令复制文件</a><li><a href="/story/13196.html">如何更改默认的crontab编辑器</a></ul></div></div><div id="footer">&copy 2020 fuzadu.com</div></body></html>